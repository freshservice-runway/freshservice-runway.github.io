(window["webpackJsonp_ember_auto_import_"] = window["webpackJsonp_ember_auto_import_"] || []).push([[13],{

/***/ "./node_modules/gridstack/dist/gridstack-dd.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack-dd.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * gridstack-dd.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridStackDD = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst gridstack_ddi_1 = __webpack_require__(/*! ./gridstack-ddi */ \"./node_modules/gridstack/dist/gridstack-ddi.js\");\nconst gridstack_1 = __webpack_require__(/*! ./gridstack */ \"./node_modules/gridstack/dist/gridstack.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/**\r\n * Base class implementing common Grid drag'n'drop functionality, with domain specific subclass (h5 vs jq subclasses)\r\n */\nclass GridStackDD extends gridstack_ddi_1.GridStackDDI {\n  /** override to cast to correct type */\n  static get() {\n    return gridstack_ddi_1.GridStackDDI.get();\n  }\n  /** removes any drag&drop present (called during destroy) */\n  remove(el) {\n    this.draggable(el, 'destroy').resizable(el, 'destroy');\n    if (el.gridstackNode) {\n      delete el.gridstackNode._initDD; // reset our DD init flag\n    }\n    return this;\n  }\n}\nexports.GridStackDD = GridStackDD;\n/********************************************************************************\r\n * GridStack code that is doing drag&drop extracted here so main class is smaller\r\n * for static grid that don't do any of this work anyway. Saves about 10k.\r\n * TODO: no code hint in code below as this is <any> so look at alternatives ?\r\n * https://www.typescriptlang.org/docs/handbook/declaration-merging.html\r\n * https://www.typescriptlang.org/docs/handbook/mixins.html\r\n ********************************************************************************/\n/** @internal called to add drag over to support widgets being added externally */\ngridstack_1.GridStack.prototype._setupAcceptWidget = function () {\n  // check if we need to disable things\n  if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n    GridStackDD.get().droppable(this.el, 'destroy');\n    return this;\n  }\n  // vars shared across all methods\n  let gridPos;\n  let cellHeight, cellWidth;\n  let onDrag = (event, el, helper) => {\n    let node = el.gridstackNode;\n    if (!node) return;\n    helper = helper || el;\n    let rec = helper.getBoundingClientRect();\n    let left = rec.left - gridPos.left;\n    let top = rec.top - gridPos.top;\n    let ui = {\n      position: {\n        top,\n        left\n      }\n    };\n    if (node._temporaryRemoved) {\n      node.x = Math.max(0, Math.round(left / cellWidth));\n      node.y = Math.max(0, Math.round(top / cellHeight));\n      delete node.autoPosition;\n      this.engine.nodeBoundFix(node);\n      // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n      if (!this.engine.willItFit(node)) {\n        node.autoPosition = true; // ignore x,y and try for any slot...\n        if (!this.engine.willItFit(node)) {\n          GridStackDD.get().off(el, 'drag'); // stop calling us\n          return; // full grid or can't grow\n        }\n        if (node._willFitPos) {\n          // use the auto position instead #1687\n          utils_1.Utils.copyPos(node, node._willFitPos);\n          delete node._willFitPos;\n        }\n      }\n      // re-use the existing node dragging method\n      this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n    } else {\n      // re-use the existing node dragging that does so much of the collision detection\n      this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n    }\n  };\n  GridStackDD.get().droppable(this.el, {\n    accept: el => {\n      let node = el.gridstackNode;\n      // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n      if (node && node.grid === this) return true;\n      if (!this.opts.acceptWidgets) return false;\n      // check for accept method or class matching\n      let canAccept = true;\n      if (typeof this.opts.acceptWidgets === 'function') {\n        canAccept = this.opts.acceptWidgets(el);\n      } else {\n        let selector = this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets;\n        canAccept = el.matches(selector);\n      }\n      // finally check to make sure we actually have space left #1571\n      if (canAccept && node && this.opts.maxRow) {\n        let n = {\n          w: node.w,\n          h: node.h,\n          minW: node.minW,\n          minH: node.minH\n        }; // only width/height matters and autoPosition\n        canAccept = this.engine.willItFit(n);\n      }\n      return canAccept;\n    }\n  })\n  /**\r\n   * entering our grid area\r\n   */.on(this.el, 'dropover', (event, el, helper) => {\n    let node = el.gridstackNode;\n    // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n    if (node && node.grid === this && !node._temporaryRemoved) {\n      // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n      return false; // prevent parent from receiving msg (which may be a grid as well)\n    }\n    // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n    if (node && node.grid && node.grid !== this && !node._temporaryRemoved) {\n      // TEST console.log('dropover without leave');\n      let otherGrid = node.grid;\n      otherGrid._leave(el, helper);\n    }\n    // get grid screen coordinates and cell dimensions\n    let box = this.el.getBoundingClientRect();\n    gridPos = {\n      top: box.top,\n      left: box.left\n    };\n    cellWidth = this.cellWidth();\n    cellHeight = this.getCellHeight(true);\n    // load any element attributes if we don't have a node\n    if (!node) {\n      // @ts-ignore\n      node = this._readAttr(el);\n    }\n    if (!node.grid) {\n      node._isExternal = true;\n      el.gridstackNode = node;\n    }\n    // calculate the grid size based on element outer size\n    helper = helper || el;\n    let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n    let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n    // if the item came from another grid, make a copy and save the original info in case we go back there\n    if (node.grid && node.grid !== this) {\n      // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n      // TEST console.log('dropover cloning node');\n      if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n      el.gridstackNode = node = Object.assign(Object.assign({}, node), {\n        w,\n        h,\n        grid: this\n      });\n      this.engine.cleanupNode(node).nodeBoundFix(node);\n      // restore some internal fields we need after clearing them all\n      node._initDD = node._isExternal =\n      // DOM needs to be re-parented on a drop\n      node._temporaryRemoved = true; // so it can be inserted onDrag below\n    } else {\n      node.w = w;\n      node.h = h;\n      node._temporaryRemoved = true; // so we can insert it\n    }\n    // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n    _itemRemoving(node.el, false);\n    GridStackDD.get().on(el, 'drag', onDrag);\n    // make sure this is called at least once when going fast #1578\n    onDrag(event, el, helper);\n    return false; // prevent parent from receiving msg (which may be a grid as well)\n  })\n  /**\r\n   * Leaving our grid area...\r\n   */.on(this.el, 'dropout', (event, el, helper) => {\n    let node = el.gridstackNode;\n    // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n    // so skip this one if we're not the active grid really..\n    if (!node.grid || node.grid === this) {\n      this._leave(el, helper);\n    }\n    return false; // prevent parent from receiving msg (which may be grid as well)\n  })\n  /**\r\n   * end - releasing the mouse\r\n   */.on(this.el, 'drop', (event, el, helper) => {\n    let node = el.gridstackNode;\n    // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n    if (node && node.grid === this && !node._isExternal) return false;\n    let wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n    this.placeholder.remove();\n    // notify previous grid of removal\n    // TEST console.log('drop delete _gridstackNodeOrig')\n    let origNode = el._gridstackNodeOrig;\n    delete el._gridstackNodeOrig;\n    if (wasAdded && origNode && origNode.grid && origNode.grid !== this) {\n      let oGrid = origNode.grid;\n      oGrid.engine.removedNodes.push(origNode);\n      oGrid._triggerRemoveEvent();\n    }\n    if (!node) return false;\n    // use existing placeholder node as it's already in our list with drop location\n    if (wasAdded) {\n      this.engine.cleanupNode(node); // removes all internal _xyz values\n      node.grid = this;\n    }\n    GridStackDD.get().off(el, 'drag');\n    // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n    // as the helper will be nuked by jquery-ui otherwise\n    if (helper !== el) {\n      helper.remove();\n      el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n      if (wasAdded) {\n        el = el.cloneNode(true);\n      }\n    } else {\n      el.remove(); // reduce flicker as we change depth here, and size further down\n      GridStackDD.get().remove(el);\n    }\n    if (!wasAdded) return false;\n    el.gridstackNode = node;\n    node.el = el;\n    // @ts-ignore\n    utils_1.Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n    utils_1.Utils.removePositioningStyles(el); // @ts-ignore\n    this._writeAttr(el, node);\n    this.el.appendChild(el); // @ts-ignore\n    this._updateContainerHeight();\n    this.engine.addedNodes.push(node); // @ts-ignore\n    this._triggerAddEvent(); // @ts-ignore\n    this._triggerChangeEvent();\n    this.engine.endUpdate();\n    if (this._gsEventHandler['dropped']) {\n      this._gsEventHandler['dropped']({\n        type: 'dropped'\n      }, origNode && origNode.grid ? origNode : undefined, node);\n    }\n    // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\n    window.setTimeout(() => {\n      // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\n      if (node.el && node.el.parentElement) {\n        this._prepareDragDropByNode(node);\n      } else {\n        this.engine.removeNode(node);\n      }\n    });\n    return false; // prevent parent from receiving msg (which may be grid as well)\n  });\n  return this;\n};\n/** @internal mark item for removal */\nfunction _itemRemoving(el, remove) {\n  let node = el ? el.gridstackNode : undefined;\n  if (!node || !node.grid) return;\n  remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n  remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\n}\n/** @internal called to setup a trash drop zone if the user specifies it */\ngridstack_1.GridStack.prototype._setupRemoveDrop = function () {\n  if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\n    let trashEl = document.querySelector(this.opts.removable);\n    if (!trashEl) return this;\n    // only register ONE drop-over/dropout callback for the 'trash', and it will\n    // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n    // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n    if (!GridStackDD.get().isDroppable(trashEl)) {\n      GridStackDD.get().droppable(trashEl, this.opts.removableOptions).on(trashEl, 'dropover', (event, el) => _itemRemoving(el, true)).on(trashEl, 'dropout', (event, el) => _itemRemoving(el, false));\n    }\n  }\n  return this;\n};\n/**\r\n * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n * Called during GridStack.init() as options, but can also be called directly (last param are cached) in case the toolbar\r\n * is dynamically create and needs to change later.\r\n **/\ngridstack_1.GridStack.setupDragIn = function (_dragIn, _dragInOptions) {\n  let dragIn;\n  let dragInOptions;\n  const dragInDefaultOptions = {\n    revert: 'invalid',\n    handle: '.grid-stack-item-content',\n    scroll: false,\n    appendTo: 'body'\n  };\n  // cache in the passed in values (form grid init?) so they don't have to resend them each time\n  if (_dragIn) {\n    dragIn = _dragIn;\n    dragInOptions = Object.assign(Object.assign({}, dragInDefaultOptions), _dragInOptions || {});\n  }\n  if (typeof dragIn !== 'string') return;\n  let dd = GridStackDD.get();\n  utils_1.Utils.getElements(dragIn).forEach(el => {\n    if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n  });\n};\n/** @internal prepares the element for drag&drop **/\ngridstack_1.GridStack.prototype._prepareDragDropByNode = function (node) {\n  let el = node.el;\n  let dd = GridStackDD.get();\n  // check for disabled grid first\n  if (this.opts.staticGrid || (node.noMove || this.opts.disableDrag) && (node.noResize || this.opts.disableResize)) {\n    if (node._initDD) {\n      dd.remove(el); // nukes everything instead of just disable, will add some styles back next\n      delete node._initDD;\n    }\n    el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\n    return this;\n  }\n  if (!node._initDD) {\n    // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n    let cellWidth;\n    let cellHeight;\n    /** called when item starts moving/resizing */\n    let onStartMoving = (event, ui) => {\n      // trigger any 'dragstart' / 'resizestart' manually\n      if (this._gsEventHandler[event.type]) {\n        this._gsEventHandler[event.type](event, event.target);\n      }\n      cellWidth = this.cellWidth();\n      cellHeight = this.getCellHeight(true); // force pixels for calculations\n      this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n    };\n    /** called when item is being dragged/resized */\n    let dragOrResize = (event, ui) => {\n      this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n    };\n    /** called when the item stops moving/resizing */\n    let onEndMoving = event => {\n      this.placeholder.remove();\n      delete node._moving;\n      delete node._lastTried;\n      // if the item has moved to another grid, we're done here\n      let target = event.target;\n      if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n      node.el = target;\n      if (node._isAboutToRemove) {\n        let gridToNotify = el.gridstackNode.grid;\n        if (gridToNotify._gsEventHandler[event.type]) {\n          gridToNotify._gsEventHandler[event.type](event, target);\n        }\n        dd.remove(el);\n        gridToNotify.engine.removedNodes.push(node);\n        gridToNotify._triggerRemoveEvent();\n        // break circular links and remove DOM\n        delete el.gridstackNode;\n        delete node.el;\n        el.remove();\n      } else {\n        if (!node._temporaryRemoved) {\n          // move to new placeholder location\n          utils_1.Utils.removePositioningStyles(target); // @ts-ignore\n          this._writePosAttr(target, node);\n        } else {\n          // got removed - restore item back to before dragging position\n          utils_1.Utils.removePositioningStyles(target);\n          utils_1.Utils.copyPos(node, node._orig); // @ts-ignore\n          this._writePosAttr(target, node);\n          this.engine.addNode(node);\n        }\n        if (this._gsEventHandler[event.type]) {\n          this._gsEventHandler[event.type](event, target);\n        }\n      }\n      // @ts-ignore\n      this._extraDragRow = 0; // @ts-ignore\n      this._updateContainerHeight(); // @ts-ignore\n      this._triggerChangeEvent();\n      this.engine.endUpdate();\n    };\n    dd.draggable(el, {\n      start: onStartMoving,\n      stop: onEndMoving,\n      drag: dragOrResize\n    }).resizable(el, {\n      start: onStartMoving,\n      stop: onEndMoving,\n      resize: dragOrResize\n    });\n    node._initDD = true; // we've set DD support now\n  }\n  // finally fine tune move vs resize by disabling any part...\n  if (node.noMove || this.opts.disableDrag) {\n    dd.draggable(el, 'disable');\n    el.classList.add('ui-draggable-disabled');\n  } else {\n    dd.draggable(el, 'enable');\n    el.classList.remove('ui-draggable-disabled');\n  }\n  if (node.noResize || this.opts.disableResize) {\n    dd.resizable(el, 'disable');\n    el.classList.add('ui-resizable-disabled');\n  } else {\n    dd.resizable(el, 'enable');\n    el.classList.remove('ui-resizable-disabled');\n  }\n  return this;\n};\n/** @internal called when item is starting a drag/resize */\ngridstack_1.GridStack.prototype._onStartMoving = function (el, event, ui, node, cellWidth, cellHeight) {\n  this.engine.cleanNodes().beginUpdate(node);\n  // @ts-ignore\n  this._writePosAttr(this.placeholder, node);\n  this.el.appendChild(this.placeholder);\n  // TEST console.log('_onStartMoving placeholder')\n  node.el = this.placeholder;\n  node._lastUiPosition = ui.position;\n  node._prevYPix = ui.position.top;\n  node._moving = event.type === 'dragstart'; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n  delete node._lastTried;\n  if (event.type === 'dropover' && node._temporaryRemoved) {\n    // TEST console.log('engine.addNode x=' + node.x);\n    this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n    node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n  }\n  // set the min/max resize info\n  this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n  if (event.type === 'resizestart') {\n    let dd = GridStackDD.get().resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1)).resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\n    if (node.maxW) {\n      dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW);\n    }\n    if (node.maxH) {\n      dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH);\n    }\n  }\n};\n/** @internal called when item leaving our area by either cursor dropout event\r\n * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n * our item to start with else restore prev node values from prev grid it came from.\r\n **/\ngridstack_1.GridStack.prototype._leave = function (el, helper) {\n  let node = el.gridstackNode;\n  if (!node) return;\n  GridStackDD.get().off(el, 'drag'); // no need to track while being outside\n  // this gets called when cursor leaves and shape is outside, so only do this once\n  if (node._temporaryRemoved) return;\n  node._temporaryRemoved = true;\n  this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n  node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n  if (this.opts.removable === true) {\n    // boolean vs a class string\n    // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n    _itemRemoving(el, true);\n  }\n  // finally if item originally came from another grid, but left us, restore things back to prev info\n  if (el._gridstackNodeOrig) {\n    // TEST console.log('leave delete _gridstackNodeOrig')\n    el.gridstackNode = el._gridstackNodeOrig;\n    delete el._gridstackNodeOrig;\n  } else if (node._isExternal) {\n    // item came from outside (like a toolbar) so nuke any node info\n    delete node.el;\n    delete el.gridstackNode;\n    // and restore all nodes back to original\n    this.engine.restoreInitial();\n  }\n};\n/** @internal called when item is being dragged/resized */\ngridstack_1.GridStack.prototype._dragOrResize = function (el, event, ui, node, cellWidth, cellHeight) {\n  let p = Object.assign({}, node._orig); // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n  let resizing;\n  const mLeft = this.opts.marginLeft,\n    mRight = this.opts.marginRight,\n    mTop = this.opts.marginTop,\n    mBottom = this.opts.marginBottom;\n  if (event.type === 'drag') {\n    if (node._temporaryRemoved) return; // handled by dropover\n    let distance = ui.position.top - node._prevYPix;\n    node._prevYPix = ui.position.top;\n    utils_1.Utils.updateScrollPosition(el, ui.position, distance);\n    // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n    let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n    let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n    p.x = Math.round(left / cellWidth);\n    p.y = Math.round(top / cellHeight);\n    // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n    let prev = this._extraDragRow;\n    if (this.engine.collide(node, p)) {\n      let row = this.getRow();\n      let extra = Math.max(0, p.y + node.h - row);\n      if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n        extra = Math.max(0, this.opts.maxRow - row);\n      } // @ts-ignore\n      this._extraDragRow = extra; // @ts-ignore\n    } else this._extraDragRow = 0; // @ts-ignore\n    if (this._extraDragRow !== prev) this._updateContainerHeight();\n    if (node.x === p.x && node.y === p.y) return; // skip same\n    // DON'T skip one we tried as we might have failed because of coverage <50% before\n    // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n  } else if (event.type === 'resize') {\n    if (p.x < 0) return;\n    // Scrolling page if needed\n    utils_1.Utils.updateScrollResize(event, el, cellHeight);\n    // get new size\n    p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n    p.h = Math.round((ui.size.height - mTop) / cellHeight);\n    if (node.w === p.w && node.h === p.h) return;\n    if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n    // if we size on left/top side this might move us, so get possible new position as well\n    let left = ui.position.left + mLeft;\n    let top = ui.position.top + mTop;\n    p.x = Math.round(left / cellWidth);\n    p.y = Math.round(top / cellHeight);\n    resizing = true;\n  }\n  node._lastTried = p; // set as last tried (will nuke if we go there)\n  let rect = {\n    x: ui.position.left + mLeft,\n    y: ui.position.top + mTop,\n    w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n    h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n  };\n  if (this.engine.moveNodeCheck(node, Object.assign(Object.assign({}, p), {\n    cellWidth,\n    cellHeight,\n    rect\n  }))) {\n    node._lastUiPosition = ui.position;\n    this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n    delete node._skipDown;\n    if (resizing && node.subGrid) {\n      node.subGrid.onParentResize();\n    } // @ts-ignore\n    this._extraDragRow = 0; // @ts-ignore\n    this._updateContainerHeight();\n    let target = event.target; // @ts-ignore\n    this._writePosAttr(target, node);\n    if (this._gsEventHandler[event.type]) {\n      this._gsEventHandler[event.type](event, target);\n    }\n  }\n};\n/**\r\n * Enables/Disables moving.\r\n * @param els widget or selector to modify.\r\n * @param val if true widget will be draggable.\r\n */\ngridstack_1.GridStack.prototype.movable = function (els, val) {\n  if (this.opts.staticGrid) return this; // can't move a static grid!\n  gridstack_1.GridStack.getElements(els).forEach(el => {\n    let node = el.gridstackNode;\n    if (!node) return;\n    if (val) delete node.noMove;else node.noMove = true;\n    this._prepareDragDropByNode(node); // init DD if need be, and adjust\n  });\n  return this;\n};\n/**\r\n * Enables/Disables resizing.\r\n * @param els  widget or selector to modify\r\n * @param val  if true widget will be resizable.\r\n */\ngridstack_1.GridStack.prototype.resizable = function (els, val) {\n  if (this.opts.staticGrid) return this; // can't resize a static grid!\n  gridstack_1.GridStack.getElements(els).forEach(el => {\n    let node = el.gridstackNode;\n    if (!node) return;\n    if (val) delete node.noResize;else node.noResize = true;\n    this._prepareDragDropByNode(node); // init DD if need be, and adjust\n  });\n  return this;\n};\n/**\r\n  * Temporarily disables widgets moving/resizing.\r\n  * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n  * Note: no-op for static grid\r\n  * This is a shortcut for:\r\n  * @example\r\n  *  grid.enableMove(false);\r\n  *  grid.enableResize(false);\r\n  */\ngridstack_1.GridStack.prototype.disable = function () {\n  if (this.opts.staticGrid) return;\n  this.enableMove(false);\n  this.enableResize(false); // @ts-ignore\n  this._triggerEvent('disable');\n  return this;\n};\n/**\r\n  * Re-enables widgets moving/resizing - see disable().\r\n  * Note: no-op for static grid.\r\n  * This is a shortcut for:\r\n  * @example\r\n  *  grid.enableMove(true);\r\n  *  grid.enableResize(true);\r\n  */\ngridstack_1.GridStack.prototype.enable = function () {\n  if (this.opts.staticGrid) return;\n  this.enableMove(true);\n  this.enableResize(true); // @ts-ignore\n  this._triggerEvent('enable');\n  return this;\n};\n/** Enables/disables widget moving. No-op for static grids. */\ngridstack_1.GridStack.prototype.enableMove = function (doEnable) {\n  if (this.opts.staticGrid) return this; // can't move a static grid!\n  this.opts.disableDrag = !doEnable; // FIRST before we update children as grid overrides #1658\n  this.engine.nodes.forEach(n => this.movable(n.el, doEnable));\n  return this;\n};\n/** Enables/disables widget resizing. No-op for static grids. */\ngridstack_1.GridStack.prototype.enableResize = function (doEnable) {\n  if (this.opts.staticGrid) return this; // can't size a static grid!\n  this.opts.disableResize = !doEnable; // FIRST before we update children as grid overrides #1658\n  this.engine.nodes.forEach(n => this.resizable(n.el, doEnable));\n  return this;\n};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/gridstack-dd.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-base-impl.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-base-impl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-base-impl.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDBaseImplement = void 0;\nclass DDBaseImplement {\n  constructor() {\n    /** @internal */\n    this._disabled = false;\n    /** @internal */\n    this._eventRegister = {};\n  }\n  /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */\n  get disabled() {\n    return this._disabled;\n  }\n  on(event, callback) {\n    this._eventRegister[event] = callback;\n  }\n  off(event) {\n    delete this._eventRegister[event];\n  }\n  enable() {\n    this._disabled = false;\n  }\n  disable() {\n    this._disabled = true;\n  }\n  destroy() {\n    delete this._eventRegister;\n  }\n  triggerEvent(eventName, event) {\n    if (!this.disabled && this._eventRegister && this._eventRegister[eventName]) return this._eventRegister[eventName](event);\n  }\n}\nexports.DDBaseImplement = DDBaseImplement;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-base-impl.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-draggable.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-draggable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-draggable.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDDraggable = void 0;\nconst dd_manager_1 = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/h5/dd-manager.js\");\nconst dd_utils_1 = __webpack_require__(/*! ./dd-utils */ \"./node_modules/gridstack/dist/h5/dd-utils.js\");\nconst dd_base_impl_1 = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/h5/dd-base-impl.js\");\nclass DDDraggable extends dd_base_impl_1.DDBaseImplement {\n  constructor(el, option = {}) {\n    super();\n    /** @internal */\n    this.dragging = false;\n    /** @internal TODO: set to public as called by DDDroppable! */\n    this.ui = () => {\n      const containmentEl = this.el.parentElement;\n      const containmentRect = containmentEl.getBoundingClientRect();\n      const offset = this.helper.getBoundingClientRect();\n      return {\n        position: {\n          top: offset.top - containmentRect.top,\n          left: offset.left - containmentRect.left\n        }\n        /* not used by GridStack for now...\r\n        helper: [this.helper], //The object arr representing the helper that's being dragged.\r\n        offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\r\n        */\n      };\n    };\n    this.el = el;\n    this.option = option;\n    // get the element that is actually supposed to be dragged by\n    let className = option.handle.substring(1);\n    this.dragEl = el.classList.contains(className) ? el : el.querySelector(option.handle) || el;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._dragStart = this._dragStart.bind(this);\n    this._drag = this._drag.bind(this);\n    this._dragEnd = this._dragEnd.bind(this);\n    this.enable();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    super.enable();\n    this.dragEl.draggable = true;\n    this.dragEl.addEventListener('dragstart', this._dragStart);\n    this.el.classList.remove('ui-draggable-disabled');\n    this.el.classList.add('ui-draggable');\n  }\n  disable(forDestroy = false) {\n    super.disable();\n    this.dragEl.removeAttribute('draggable');\n    this.dragEl.removeEventListener('dragstart', this._dragStart);\n    this.el.classList.remove('ui-draggable');\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n  destroy() {\n    if (this.dragging) {\n      // Destroy while dragging should remove dragend listener and manually trigger\n      // dragend, otherwise dragEnd can't perform dragstop because eventRegistry is\n      // destroyed.\n      this._dragEnd({});\n    }\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n  updateOption(opts) {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n  /** @internal */\n  _dragStart(event) {\n    dd_manager_1.DDManager.dragElement = this;\n    this.helper = this._createHelper(event);\n    this._setupHelperContainmentStyle();\n    this.dragOffset = this._getDragOffset(event, this.el, this.helperContainment);\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      target: this.el,\n      type: 'dragstart'\n    });\n    if (this.helper !== this.el) {\n      this._setupDragFollowNodeNotifyStart(ev);\n      // immediately set external helper initial position to avoid flickering behavior and unnecessary looping in `_packNodes()`\n      this._dragFollow(event);\n    } else {\n      this.dragFollowTimer = window.setTimeout(() => {\n        delete this.dragFollowTimer;\n        this._setupDragFollowNodeNotifyStart(ev);\n      }, 0);\n    }\n    this._cancelDragGhost(event);\n  }\n  /** @internal */\n  _setupDragFollowNodeNotifyStart(ev) {\n    this._setupHelperStyle();\n    document.addEventListener('dragover', this._drag, DDDraggable.dragEventListenerOption);\n    this.dragEl.addEventListener('dragend', this._dragEnd);\n    if (this.option.start) {\n      this.option.start(ev, this.ui());\n    }\n    this.dragging = true;\n    this.helper.classList.add('ui-draggable-dragging');\n    this.triggerEvent('dragstart', ev);\n    return this;\n  }\n  /** @internal */\n  _drag(event) {\n    // Safari: prevent default to allow drop to happen instead of reverting back (with animation) and delaying dragend #1541\n    // https://stackoverflow.com/questions/61760755/how-to-fire-dragend-event-immediately\n    event.preventDefault();\n    this._dragFollow(event);\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      target: this.el,\n      type: 'drag'\n    });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n  /** @internal */\n  _dragEnd(event) {\n    if (this.dragFollowTimer) {\n      clearTimeout(this.dragFollowTimer);\n      delete this.dragFollowTimer;\n      return;\n    } else {\n      if (this.paintTimer) {\n        cancelAnimationFrame(this.paintTimer);\n      }\n      document.removeEventListener('dragover', this._drag, DDDraggable.dragEventListenerOption);\n      this.dragEl.removeEventListener('dragend', this._dragEnd);\n    }\n    this.dragging = false;\n    this.helper.classList.remove('ui-draggable-dragging');\n    this.helperContainment.style.position = this.parentOriginStylePosition || null;\n    if (this.helper === this.el) {\n      this._removeHelperStyle();\n    } else {\n      this.helper.remove();\n    }\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      target: this.el,\n      type: 'dragstop'\n    });\n    if (this.option.stop) {\n      this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n    }\n    this.triggerEvent('dragstop', ev);\n    delete dd_manager_1.DDManager.dragElement;\n    delete this.helper;\n  }\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  _createHelper(event) {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(event);\n    } else if (this.option.helper === 'clone') {\n      helper = dd_utils_1.DDUtils.clone(this.el);\n    }\n    if (!document.body.contains(helper)) {\n      dd_utils_1.DDUtils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentNode : this.option.appendTo);\n    }\n    if (helper === this.el) {\n      this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    }\n    return helper;\n  }\n  /** @internal */\n  _setupHelperStyle() {\n    this.helper.style.pointerEvents = 'none';\n    this.helper.style.width = this.dragOffset.width + 'px';\n    this.helper.style.height = this.dragOffset.height + 'px';\n    this.helper.style.willChange = 'left, top';\n    this.helper.style.transition = 'none'; // show up instantly\n    this.helper.style.position = this.option.basePosition || DDDraggable.basePosition;\n    this.helper.style.zIndex = '1000';\n    setTimeout(() => {\n      if (this.helper) {\n        this.helper.style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n  /** @internal */\n  _removeHelperStyle() {\n    // don't bother restoring styles if we're gonna remove anyway...\n    let node = this.helper ? this.helper.gridstackNode : undefined;\n    if (!node || !node._isAboutToRemove) {\n      DDDraggable.originStyleProp.forEach(prop => {\n        this.helper.style[prop] = this.dragElementOriginStyle[prop] || null;\n      });\n    }\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n  /** @internal */\n  _dragFollow(event) {\n    if (this.paintTimer) {\n      cancelAnimationFrame(this.paintTimer);\n    }\n    this.paintTimer = requestAnimationFrame(() => {\n      delete this.paintTimer;\n      const offset = this.dragOffset;\n      let containmentRect = {\n        left: 0,\n        top: 0\n      };\n      if (this.helper.style.position === 'absolute') {\n        const {\n          left,\n          top\n        } = this.helperContainment.getBoundingClientRect();\n        containmentRect = {\n          left,\n          top\n        };\n      }\n      this.helper.style.left = event.clientX + offset.offsetLeft - containmentRect.left + 'px';\n      this.helper.style.top = event.clientY + offset.offsetTop - containmentRect.top + 'px';\n    });\n  }\n  /** @internal */\n  _setupHelperContainmentStyle() {\n    this.helperContainment = this.helper.parentElement;\n    if (this.option.basePosition !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (window.getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n  /** @internal prevent the default gost image to be created (which has wrongas we move the helper/element instead\r\n   * (legacy jquery UI code updates the top/left of the item).\r\n   * TODO: maybe use mouse event instead of HTML5 drag as we have to work around it anyway, or change code to not update\r\n   * the actual grid-item but move the gost image around (and special case jq version) ?\r\n   **/\n  _cancelDragGhost(e) {\n    /* doesn't seem to do anything...\r\n    let t = e.dataTransfer;\r\n    t.effectAllowed = 'none';\r\n    t.dropEffect = 'none';\r\n    t.setData('text', '');\r\n    */\n    // NOTE: according to spec (and required by Safari see #1540) the image has to be visible in the browser (in dom and not hidden) so make it a 1px div\n    let img = document.createElement('div');\n    img.style.width = '1px';\n    img.style.height = '1px';\n    img.style.position = 'fixed'; // prevent unwanted scrollbar\n    document.body.appendChild(img);\n    e.dataTransfer.setDragImage(img, 0, 0);\n    setTimeout(() => document.body.removeChild(img)); // nuke once drag had a chance to grab this 'image'\n    e.stopPropagation();\n    return this;\n  }\n  /** @internal */\n  _getDragOffset(event, el, parent) {\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      const testEl = document.createElement('div');\n      dd_utils_1.DDUtils.addElStyles(testEl, {\n        opacity: '0',\n        position: 'fixed',\n        top: 0 + 'px',\n        left: 0 + 'px',\n        width: '1px',\n        height: '1px',\n        zIndex: '-999999'\n      });\n      parent.appendChild(testEl);\n      const testElPosition = testEl.getBoundingClientRect();\n      parent.removeChild(testEl);\n      xformOffsetX = testElPosition.left;\n      xformOffsetY = testElPosition.top;\n      // TODO: scale ?\n    }\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width,\n      height: targetOffset.height\n    };\n  }\n}\nexports.DDDraggable = DDDraggable;\n/** @internal */\nDDDraggable.basePosition = 'absolute';\n/** @internal #1541 can't have {passive: true} on Safari as otherwise it reverts animate back to old location on drop */\nDDDraggable.dragEventListenerOption = true; // DDUtils.isEventSupportPassiveOption ? { capture: true, passive: true } : true;\n/** @internal */\nDDDraggable.originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'opacity', 'zIndex', 'width', 'height', 'willChange'];\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-draggable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-droppable.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-droppable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-droppable.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDDroppable = void 0;\nconst dd_manager_1 = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/h5/dd-manager.js\");\nconst dd_base_impl_1 = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/h5/dd-base-impl.js\");\nconst dd_utils_1 = __webpack_require__(/*! ./dd-utils */ \"./node_modules/gridstack/dist/h5/dd-utils.js\");\nclass DDDroppable extends dd_base_impl_1.DDBaseImplement {\n  constructor(el, opts = {}) {\n    super();\n    this.el = el;\n    this.option = opts;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._dragEnter = this._dragEnter.bind(this);\n    this._dragOver = this._dragOver.bind(this);\n    this._dragLeave = this._dragLeave.bind(this);\n    this._drop = this._drop.bind(this);\n    this.el.classList.add('ui-droppable');\n    this.el.addEventListener('dragenter', this._dragEnter);\n    this._setupAccept();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    if (!this.disabled) return;\n    super.enable();\n    this.el.classList.remove('ui-droppable-disabled');\n    this.el.addEventListener('dragenter', this._dragEnter);\n  }\n  disable(forDestroy = false) {\n    if (this.disabled) return;\n    super.disable();\n    if (!forDestroy) this.el.classList.add('ui-droppable-disabled');\n    this.el.removeEventListener('dragenter', this._dragEnter);\n  }\n  destroy() {\n    if (this.moving) {\n      this._removeLeaveCallbacks();\n    }\n    this.disable(true);\n    this.el.classList.remove('ui-droppable');\n    this.el.classList.remove('ui-droppable-disabled');\n    delete this.moving;\n    super.destroy();\n  }\n  updateOption(opts) {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    this._setupAccept();\n    return this;\n  }\n  /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */\n  _dragEnter(event) {\n    if (!this._canDrop()) return;\n    event.preventDefault();\n    if (this.moving) return; // ignore multiple 'dragenter' as we go over existing items\n    this.moving = true;\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      target: this.el,\n      type: 'dropover'\n    });\n    if (this.option.over) {\n      this.option.over(ev, this._ui(dd_manager_1.DDManager.dragElement));\n    }\n    this.triggerEvent('dropover', ev);\n    this.el.addEventListener('dragover', this._dragOver);\n    this.el.addEventListener('drop', this._drop);\n    this.el.addEventListener('dragleave', this._dragLeave);\n    this.el.classList.add('ui-droppable-over');\n  }\n  /** @internal called when an moving to drop item is being dragged over - do nothing but eat the event */\n  _dragOver(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  /** @internal called when the item is leaving our area, stop tracking if we had moving item */\n  _dragLeave(event) {\n    // ignore leave events on our children (get when starting to drag our items)\n    // Note: Safari Mac has null relatedTarget which causes #1684 so check if DragEvent is inside the grid instead\n    if (!event.relatedTarget) {\n      const {\n        bottom,\n        left,\n        right,\n        top\n      } = this.el.getBoundingClientRect();\n      if (event.x < right && event.x > left && event.y < bottom && event.y > top) return;\n    } else if (this.el.contains(event.relatedTarget)) return;\n    this._removeLeaveCallbacks();\n    if (this.moving) {\n      event.preventDefault();\n      const ev = dd_utils_1.DDUtils.initEvent(event, {\n        target: this.el,\n        type: 'dropout'\n      });\n      if (this.option.out) {\n        this.option.out(ev, this._ui(dd_manager_1.DDManager.dragElement));\n      }\n      this.triggerEvent('dropout', ev);\n    }\n    delete this.moving;\n  }\n  /** @internal item is being dropped on us - call the client drop event */\n  _drop(event) {\n    if (!this.moving) return; // should not have received event...\n    event.preventDefault();\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      target: this.el,\n      type: 'drop'\n    });\n    if (this.option.drop) {\n      this.option.drop(ev, this._ui(dd_manager_1.DDManager.dragElement));\n    }\n    this.triggerEvent('drop', ev);\n    this._removeLeaveCallbacks();\n    delete this.moving;\n  }\n  /** @internal called to remove callbacks when leaving or dropping */\n  _removeLeaveCallbacks() {\n    this.el.removeEventListener('dragleave', this._dragLeave);\n    this.el.classList.remove('ui-droppable-over');\n    if (this.moving) {\n      this.el.removeEventListener('dragover', this._dragOver);\n      this.el.removeEventListener('drop', this._drop);\n    }\n    // Note: this.moving is reset by callee of this routine to control the flow\n  }\n  /** @internal */\n  _canDrop() {\n    return dd_manager_1.DDManager.dragElement && (!this.accept || this.accept(dd_manager_1.DDManager.dragElement.el));\n  }\n  /** @internal */\n  _setupAccept() {\n    if (this.option.accept && typeof this.option.accept === 'string') {\n      this.accept = el => {\n        return el.matches(this.option.accept);\n      };\n    } else {\n      this.accept = this.option.accept;\n    }\n    return this;\n  }\n  /** @internal */\n  _ui(drag) {\n    return Object.assign({\n      draggable: drag.el\n    }, drag.ui());\n  }\n}\nexports.DDDroppable = DDDroppable;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-droppable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-element.js":
/*!******************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-element.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-elements.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDElement = void 0;\nconst dd_resizable_1 = __webpack_require__(/*! ./dd-resizable */ \"./node_modules/gridstack/dist/h5/dd-resizable.js\");\nconst dd_draggable_1 = __webpack_require__(/*! ./dd-draggable */ \"./node_modules/gridstack/dist/h5/dd-draggable.js\");\nconst dd_droppable_1 = __webpack_require__(/*! ./dd-droppable */ \"./node_modules/gridstack/dist/h5/dd-droppable.js\");\nclass DDElement {\n  constructor(el) {\n    this.el = el;\n  }\n  static init(el) {\n    if (!el.ddElement) {\n      el.ddElement = new DDElement(el);\n    }\n    return el.ddElement;\n  }\n  on(eventName, callback) {\n    if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n      this.ddDraggable.on(eventName, callback);\n    } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n      this.ddDroppable.on(eventName, callback);\n    } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n      this.ddResizable.on(eventName, callback);\n    }\n    return this;\n  }\n  off(eventName) {\n    if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n      this.ddDraggable.off(eventName);\n    } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n      this.ddDroppable.off(eventName);\n    } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n      this.ddResizable.off(eventName);\n    }\n    return this;\n  }\n  setupDraggable(opts) {\n    if (!this.ddDraggable) {\n      this.ddDraggable = new dd_draggable_1.DDDraggable(this.el, opts);\n    } else {\n      this.ddDraggable.updateOption(opts);\n    }\n    return this;\n  }\n  cleanDraggable() {\n    if (this.ddDraggable) {\n      this.ddDraggable.destroy();\n      delete this.ddDraggable;\n    }\n    return this;\n  }\n  setupResizable(opts) {\n    if (!this.ddResizable) {\n      this.ddResizable = new dd_resizable_1.DDResizable(this.el, opts);\n    } else {\n      this.ddResizable.updateOption(opts);\n    }\n    return this;\n  }\n  cleanResizable() {\n    if (this.ddResizable) {\n      this.ddResizable.destroy();\n      delete this.ddResizable;\n    }\n    return this;\n  }\n  setupDroppable(opts) {\n    if (!this.ddDroppable) {\n      this.ddDroppable = new dd_droppable_1.DDDroppable(this.el, opts);\n    } else {\n      this.ddDroppable.updateOption(opts);\n    }\n    return this;\n  }\n  cleanDroppable() {\n    if (this.ddDroppable) {\n      this.ddDroppable.destroy();\n      delete this.ddDroppable;\n    }\n    return this;\n  }\n}\nexports.DDElement = DDElement;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-element.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-manager.js":
/*!******************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-manager.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDManager = void 0;\nclass DDManager {}\nexports.DDManager = DDManager;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-manager.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-resizable-handle.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-resizable-handle.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-resizable-handle.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDResizableHandle = void 0;\nclass DDResizableHandle {\n  constructor(host, direction, option) {\n    /** @internal true after we've moved enough pixels to start a resize */\n    this.moving = false;\n    this.host = host;\n    this.dir = direction;\n    this.option = option;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this._init();\n  }\n  /** @internal */\n  _init() {\n    const el = document.createElement('div');\n    el.classList.add('ui-resizable-handle');\n    el.classList.add(`${DDResizableHandle.prefix}${this.dir}`);\n    el.style.zIndex = '100';\n    el.style.userSelect = 'none';\n    this.el = el;\n    this.host.appendChild(this.el);\n    this.el.addEventListener('mousedown', this._mouseDown);\n    return this;\n  }\n  /** call this when resize handle needs to be removed and cleaned up */\n  destroy() {\n    if (this.moving) this._mouseUp(this.mouseDownEvent);\n    this.el.removeEventListener('mousedown', this._mouseDown);\n    this.host.removeChild(this.el);\n    delete this.el;\n    delete this.host;\n    return this;\n  }\n  /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */\n  _mouseDown(e) {\n    e.preventDefault();\n    this.mouseDownEvent = e;\n    document.addEventListener('mousemove', this._mouseMove, true); // capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp);\n  }\n  /** @internal */\n  _mouseMove(e) {\n    let s = this.mouseDownEvent;\n    // don't start unless we've moved at least 3 pixels\n    if (!this.moving && Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {\n      this.moving = true;\n      this._triggerEvent('start', this.mouseDownEvent);\n    } else if (this.moving) {\n      this._triggerEvent('move', e);\n    }\n  }\n  /** @internal */\n  _mouseUp(e) {\n    if (this.moving) {\n      this._triggerEvent('stop', e);\n    }\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp);\n    delete this.moving;\n    delete this.mouseDownEvent;\n  }\n  /** @internal */\n  _triggerEvent(name, event) {\n    if (this.option[name]) this.option[name](event);\n    return this;\n  }\n}\nexports.DDResizableHandle = DDResizableHandle;\n/** @internal */\nDDResizableHandle.prefix = 'ui-resizable-';\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-resizable-handle.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-resizable.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-resizable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * dd-resizable.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDResizable = void 0;\nconst dd_resizable_handle_1 = __webpack_require__(/*! ./dd-resizable-handle */ \"./node_modules/gridstack/dist/h5/dd-resizable-handle.js\");\nconst dd_base_impl_1 = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/h5/dd-base-impl.js\");\nconst dd_utils_1 = __webpack_require__(/*! ./dd-utils */ \"./node_modules/gridstack/dist/h5/dd-utils.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/gridstack/dist/utils.js\");\nclass DDResizable extends dd_base_impl_1.DDBaseImplement {\n  constructor(el, opts = {}) {\n    super();\n    /** @internal */\n    this._showHandlers = () => {\n      this.el.classList.remove('ui-resizable-autohide');\n    };\n    /** @internal */\n    this._hideHandlers = () => {\n      this.el.classList.add('ui-resizable-autohide');\n    };\n    /** @internal */\n    this._ui = () => {\n      const containmentEl = this.el.parentElement;\n      const containmentRect = containmentEl.getBoundingClientRect();\n      const newRect = {\n        width: this.originalRect.width,\n        height: this.originalRect.height + this.scrolled,\n        left: this.originalRect.left,\n        top: this.originalRect.top - this.scrolled\n      };\n      const rect = this.temporalRect || newRect;\n      return {\n        position: {\n          left: rect.left - containmentRect.left,\n          top: rect.top - containmentRect.top\n        },\n        size: {\n          width: rect.width,\n          height: rect.height\n        }\n        /* Gridstack ONLY needs position set above... keep around in case.\r\n        element: [this.el], // The object representing the element to be resized\r\n        helper: [], // TODO: not support yet - The object representing the helper that's being resized\r\n        originalElement: [this.el],// we don't wrap here, so simplify as this.el //The object representing the original element before it is wrapped\r\n        originalPosition: { // The position represented as { left, top } before the resizable is resized\r\n          left: this.originalRect.left - containmentRect.left,\r\n          top: this.originalRect.top - containmentRect.top\r\n        },\r\n        originalSize: { // The size represented as { width, height } before the resizable is resized\r\n          width: this.originalRect.width,\r\n          height: this.originalRect.height\r\n        }\r\n        */\n      };\n    };\n    this.el = el;\n    this.option = opts;\n    this.enable();\n    this._setupAutoHide();\n    this._setupHandlers();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    super.enable();\n    this.el.classList.add('ui-resizable');\n    this.el.classList.remove('ui-resizable-disabled');\n  }\n  disable() {\n    super.disable();\n    this.el.classList.add('ui-resizable-disabled');\n    this.el.classList.remove('ui-resizable');\n  }\n  destroy() {\n    this._removeHandlers();\n    if (this.option.autoHide) {\n      this.el.removeEventListener('mouseover', this._showHandlers);\n      this.el.removeEventListener('mouseout', this._hideHandlers);\n    }\n    this.el.classList.remove('ui-resizable');\n    delete this.el;\n    super.destroy();\n  }\n  updateOption(opts) {\n    let updateHandles = opts.handles && opts.handles !== this.option.handles;\n    let updateAutoHide = opts.autoHide && opts.autoHide !== this.option.autoHide;\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    if (updateHandles) {\n      this._removeHandlers();\n      this._setupHandlers();\n    }\n    if (updateAutoHide) {\n      this._setupAutoHide();\n    }\n    return this;\n  }\n  /** @internal */\n  _setupAutoHide() {\n    if (this.option.autoHide) {\n      this.el.classList.add('ui-resizable-autohide');\n      // use mouseover/mouseout instead of mouseenter/mouseleave to get better performance;\n      this.el.addEventListener('mouseover', this._showHandlers);\n      this.el.addEventListener('mouseout', this._hideHandlers);\n    } else {\n      this.el.classList.remove('ui-resizable-autohide');\n      this.el.removeEventListener('mouseover', this._showHandlers);\n      this.el.removeEventListener('mouseout', this._hideHandlers);\n    }\n    return this;\n  }\n  /** @internal */\n  _setupHandlers() {\n    let handlerDirection = this.option.handles || 'e,s,se';\n    if (handlerDirection === 'all') {\n      handlerDirection = 'n,e,s,w,se,sw,ne,nw';\n    }\n    this.handlers = handlerDirection.split(',').map(dir => dir.trim()).map(dir => new dd_resizable_handle_1.DDResizableHandle(this.el, dir, {\n      start: event => {\n        this._resizeStart(event);\n      },\n      stop: event => {\n        this._resizeStop(event);\n      },\n      move: event => {\n        this._resizing(event, dir);\n      }\n    }));\n    return this;\n  }\n  /** @internal */\n  _resizeStart(event) {\n    this.originalRect = this.el.getBoundingClientRect();\n    this.scrollEl = utils_1.Utils.getScrollElement(this.el);\n    this.scrollY = this.scrollEl.scrollTop;\n    this.startEvent = event;\n    this._setupHelper();\n    this._applyChange();\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      type: 'resizestart',\n      target: this.el\n    });\n    if (this.option.start) {\n      this.option.start(ev, this._ui());\n    }\n    this.el.classList.add('ui-resizable-resizing');\n    this.triggerEvent('resizestart', ev);\n    return this;\n  }\n  /** @internal */\n  _resizing(event, dir) {\n    this.scrolled = this.scrollEl.scrollTop - this.scrollY;\n    this.temporalRect = this._getChange(event, dir);\n    this._applyChange();\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      type: 'resize',\n      target: this.el\n    });\n    if (this.option.resize) {\n      this.option.resize(ev, this._ui());\n    }\n    this.triggerEvent('resize', ev);\n    return this;\n  }\n  /** @internal */\n  _resizeStop(event) {\n    const ev = dd_utils_1.DDUtils.initEvent(event, {\n      type: 'resizestop',\n      target: this.el\n    });\n    if (this.option.stop) {\n      this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n    }\n    this.el.classList.remove('ui-resizable-resizing');\n    this.triggerEvent('resizestop', ev);\n    this._cleanHelper();\n    delete this.startEvent;\n    delete this.originalRect;\n    delete this.temporalRect;\n    delete this.scrollY;\n    delete this.scrolled;\n    return this;\n  }\n  /** @internal */\n  _setupHelper() {\n    this.elOriginStyleVal = DDResizable._originStyleProp.map(prop => this.el.style[prop]);\n    this.parentOriginStylePosition = this.el.parentElement.style.position;\n    if (window.getComputedStyle(this.el.parentElement).position.match(/static/)) {\n      this.el.parentElement.style.position = 'relative';\n    }\n    this.el.style.position = this.option.basePosition || 'absolute'; // or 'fixed'\n    this.el.style.opacity = '0.8';\n    this.el.style.zIndex = '1000';\n    return this;\n  }\n  /** @internal */\n  _cleanHelper() {\n    DDResizable._originStyleProp.forEach((prop, i) => {\n      this.el.style[prop] = this.elOriginStyleVal[i] || null;\n    });\n    this.el.parentElement.style.position = this.parentOriginStylePosition || null;\n    return this;\n  }\n  /** @internal */\n  _getChange(event, dir) {\n    const oEvent = this.startEvent;\n    const newRect = {\n      width: this.originalRect.width,\n      height: this.originalRect.height + this.scrolled,\n      left: this.originalRect.left,\n      top: this.originalRect.top - this.scrolled\n    };\n    const offsetX = event.clientX - oEvent.clientX;\n    const offsetY = event.clientY - oEvent.clientY;\n    if (dir.indexOf('e') > -1) {\n      newRect.width += offsetX;\n    } else if (dir.indexOf('w') > -1) {\n      newRect.width -= offsetX;\n      newRect.left += offsetX;\n    }\n    if (dir.indexOf('s') > -1) {\n      newRect.height += offsetY;\n    } else if (dir.indexOf('n') > -1) {\n      newRect.height -= offsetY;\n      newRect.top += offsetY;\n    }\n    const constrain = this._constrainSize(newRect.width, newRect.height);\n    if (Math.round(newRect.width) !== Math.round(constrain.width)) {\n      // round to ignore slight round-off errors\n      if (dir.indexOf('w') > -1) {\n        newRect.left += newRect.width - constrain.width;\n      }\n      newRect.width = constrain.width;\n    }\n    if (Math.round(newRect.height) !== Math.round(constrain.height)) {\n      if (dir.indexOf('n') > -1) {\n        newRect.top += newRect.height - constrain.height;\n      }\n      newRect.height = constrain.height;\n    }\n    return newRect;\n  }\n  /** @internal constrain the size to the set min/max values */\n  _constrainSize(oWidth, oHeight) {\n    const maxWidth = this.option.maxWidth || Number.MAX_SAFE_INTEGER;\n    const minWidth = this.option.minWidth || oWidth;\n    const maxHeight = this.option.maxHeight || Number.MAX_SAFE_INTEGER;\n    const minHeight = this.option.minHeight || oHeight;\n    const width = Math.min(maxWidth, Math.max(minWidth, oWidth));\n    const height = Math.min(maxHeight, Math.max(minHeight, oHeight));\n    return {\n      width,\n      height\n    };\n  }\n  /** @internal */\n  _applyChange() {\n    let containmentRect = {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n    if (this.el.style.position === 'absolute') {\n      const containmentEl = this.el.parentElement;\n      const {\n        left,\n        top\n      } = containmentEl.getBoundingClientRect();\n      containmentRect = {\n        left,\n        top,\n        width: 0,\n        height: 0\n      };\n    }\n    if (!this.temporalRect) return this;\n    Object.keys(this.temporalRect).forEach(key => {\n      const value = this.temporalRect[key];\n      this.el.style[key] = value - containmentRect[key] + 'px';\n    });\n    return this;\n  }\n  /** @internal */\n  _removeHandlers() {\n    this.handlers.forEach(handle => handle.destroy());\n    delete this.handlers;\n    return this;\n  }\n}\nexports.DDResizable = DDResizable;\n/** @internal */\nDDResizable._originStyleProp = ['width', 'height', 'position', 'left', 'top', 'opacity', 'zIndex'];\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-resizable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDUtils = void 0;\n/**\r\n * dd-utils.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nclass DDUtils {\n  static clone(el) {\n    const node = el.cloneNode(true);\n    node.removeAttribute('id');\n    return node;\n  }\n  static appendTo(el, parent) {\n    let parentNode;\n    if (typeof parent === 'string') {\n      parentNode = document.querySelector(parent);\n    } else {\n      parentNode = parent;\n    }\n    if (parentNode) {\n      parentNode.appendChild(el);\n    }\n  }\n  static setPositionRelative(el) {\n    if (!/^(?:r|a|f)/.test(window.getComputedStyle(el).position)) {\n      el.style.position = \"relative\";\n    }\n  }\n  static addElStyles(el, styles) {\n    if (styles instanceof Object) {\n      for (const s in styles) {\n        if (styles.hasOwnProperty(s)) {\n          if (Array.isArray(styles[s])) {\n            // support fallback value\n            styles[s].forEach(val => {\n              el.style[s] = val;\n            });\n          } else {\n            el.style[s] = styles[s];\n          }\n        }\n      }\n    }\n  }\n  static initEvent(e, info) {\n    const evt = {\n      type: info.type\n    };\n    const obj = {\n      button: 0,\n      which: 0,\n      buttons: 1,\n      bubbles: true,\n      cancelable: true,\n      target: info.target ? info.target : e.target\n    };\n    // don't check for `instanceof DragEvent` as Safari use MouseEvent #1540\n    if (e.dataTransfer) {\n      evt['dataTransfer'] = e.dataTransfer; // workaround 'readonly' field.\n    }\n    ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].forEach(p => evt[p] = e[p]); // keys\n    ['pageX', 'pageY', 'clientX', 'clientY', 'screenX', 'screenY'].forEach(p => evt[p] = e[p]); // point info\n    return Object.assign(Object.assign({}, evt), obj);\n  }\n}\nexports.DDUtils = DDUtils;\nDDUtils.isEventSupportPassiveOption = (() => {\n  let supportsPassive = false;\n  let passiveTest = () => {\n    // do nothing\n  };\n  document.addEventListener('test', passiveTest, {\n    get passive() {\n      supportsPassive = true;\n      return true;\n    }\n  });\n  document.removeEventListener('test', passiveTest);\n  return supportsPassive;\n})();\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-utils.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/gridstack-dd-native.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/gridstack-dd-native.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * gridstack-dd-native.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridStackDDNative = void 0;\nconst dd_manager_1 = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/h5/dd-manager.js\");\nconst dd_element_1 = __webpack_require__(/*! ./dd-element */ \"./node_modules/gridstack/dist/h5/dd-element.js\");\nconst gridstack_dd_1 = __webpack_require__(/*! ../gridstack-dd */ \"./node_modules/gridstack/dist/gridstack-dd.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/gridstack/dist/utils.js\");\n// export our base class (what user should use) and all associated types\n__exportStar(__webpack_require__(/*! ../gridstack-dd */ \"./node_modules/gridstack/dist/gridstack-dd.js\"), exports);\n/**\r\n * HTML 5 Native DragDrop based drag'n'drop plugin.\r\n */\nclass GridStackDDNative extends gridstack_dd_1.GridStackDD {\n  resizable(el, opts, key, value) {\n    this._getDDElements(el).forEach(dEl => {\n      if (opts === 'disable' || opts === 'enable') {\n        dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()\n      } else if (opts === 'destroy') {\n        dEl.ddResizable && dEl.cleanResizable();\n      } else if (opts === 'option') {\n        dEl.setupResizable({\n          [key]: value\n        });\n      } else {\n        const grid = dEl.el.gridstackNode.grid;\n        let handles = dEl.el.getAttribute('gs-resize-handles') ? dEl.el.getAttribute('gs-resize-handles') : grid.opts.resizable.handles;\n        dEl.setupResizable(Object.assign(Object.assign(Object.assign({}, grid.opts.resizable), {\n          handles: handles\n        }), {\n          start: opts.start,\n          stop: opts.stop,\n          resize: opts.resize\n        }));\n      }\n    });\n    return this;\n  }\n  draggable(el, opts, key, value) {\n    this._getDDElements(el).forEach(dEl => {\n      if (opts === 'disable' || opts === 'enable') {\n        dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()\n      } else if (opts === 'destroy') {\n        dEl.ddDraggable && dEl.cleanDraggable();\n      } else if (opts === 'option') {\n        dEl.setupDraggable({\n          [key]: value\n        });\n      } else {\n        const grid = dEl.el.gridstackNode.grid;\n        dEl.setupDraggable(Object.assign(Object.assign({}, grid.opts.draggable), {\n          containment: grid.opts._isNested && !grid.opts.dragOut ? grid.el.parentElement : grid.opts.draggable.containment || null,\n          start: opts.start,\n          stop: opts.stop,\n          drag: opts.drag\n        }));\n      }\n    });\n    return this;\n  }\n  dragIn(el, opts) {\n    this._getDDElements(el).forEach(dEl => dEl.setupDraggable(opts));\n    return this;\n  }\n  droppable(el, opts, key, value) {\n    if (typeof opts.accept === 'function' && !opts._accept) {\n      opts._accept = opts.accept;\n      opts.accept = el => opts._accept(el);\n    }\n    this._getDDElements(el).forEach(dEl => {\n      if (opts === 'disable' || opts === 'enable') {\n        dEl.ddDroppable && dEl.ddDroppable[opts]();\n      } else if (opts === 'destroy') {\n        if (dEl.ddDroppable) {\n          // error to call destroy if not there\n          dEl.cleanDroppable();\n        }\n      } else if (opts === 'option') {\n        dEl.setupDroppable({\n          [key]: value\n        });\n      } else {\n        dEl.setupDroppable(opts);\n      }\n    });\n    return this;\n  }\n  /** true if element is droppable */\n  isDroppable(el) {\n    return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);\n  }\n  /** true if element is draggable */\n  isDraggable(el) {\n    return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);\n  }\n  /** true if element is draggable */\n  isResizable(el) {\n    return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);\n  }\n  on(el, name, callback) {\n    this._getDDElements(el).forEach(dEl => dEl.on(name, event => {\n      callback(event, dd_manager_1.DDManager.dragElement ? dd_manager_1.DDManager.dragElement.el : event.target, dd_manager_1.DDManager.dragElement ? dd_manager_1.DDManager.dragElement.helper : null);\n    }));\n    return this;\n  }\n  off(el, name) {\n    this._getDDElements(el).forEach(dEl => dEl.off(name));\n    return this;\n  }\n  /** @internal returns a list of DD elements, creating them on the fly by default */\n  _getDDElements(els, create = true) {\n    let hosts = utils_1.Utils.getElements(els);\n    if (!hosts.length) return [];\n    let list = hosts.map(e => e.ddElement || (create ? dd_element_1.DDElement.init(e) : null));\n    if (!create) {\n      list.filter(d => d);\n    } // remove nulls\n    return list;\n  }\n}\nexports.GridStackDDNative = GridStackDDNative;\n// finally register ourself\ngridstack_dd_1.GridStackDD.registerPlugin(GridStackDDNative);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/gridstack-dd-native.js?");

/***/ })

}]);