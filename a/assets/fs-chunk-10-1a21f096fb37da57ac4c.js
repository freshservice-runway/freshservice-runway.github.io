(window["webpackJsonp_ember_auto_import_"] = window["webpackJsonp_ember_auto_import_"] || []).push([[10],{

/***/ "./node_modules/gridstack/dist/gridstack-dd.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack-dd.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * gridstack-dd.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridStackDD = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nvar gridstack_ddi_1 = __webpack_require__(/*! ./gridstack-ddi */ \"./node_modules/gridstack/dist/gridstack-ddi.js\");\n\nvar gridstack_1 = __webpack_require__(/*! ./gridstack */ \"./node_modules/gridstack/dist/gridstack.js\");\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/**\r\n * Base class implementing common Grid drag'n'drop functionality, with domain specific subclass (h5 vs jq subclasses)\r\n */\n\n\nvar GridStackDD = /*#__PURE__*/function (_gridstack_ddi_1$Grid) {\n  _inherits(GridStackDD, _gridstack_ddi_1$Grid);\n\n  var _super = _createSuper(GridStackDD);\n\n  function GridStackDD() {\n    _classCallCheck(this, GridStackDD);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridStackDD, [{\n    key: \"remove\",\n\n    /** removes any drag&drop present (called during destroy) */\n    value: function remove(el) {\n      this.draggable(el, 'destroy').resizable(el, 'destroy');\n\n      if (el.gridstackNode) {\n        delete el.gridstackNode._initDD; // reset our DD init flag\n      }\n\n      return this;\n    }\n  }], [{\n    key: \"get\",\n\n    /** override to cast to correct type */\n    value: function get() {\n      return gridstack_ddi_1.GridStackDDI.get();\n    }\n  }]);\n\n  return GridStackDD;\n}(gridstack_ddi_1.GridStackDDI);\n\nexports.GridStackDD = GridStackDD;\n/********************************************************************************\r\n * GridStack code that is doing drag&drop extracted here so main class is smaller\r\n * for static grid that don't do any of this work anyway. Saves about 10k.\r\n * TODO: no code hint in code below as this is <any> so look at alternatives ?\r\n * https://www.typescriptlang.org/docs/handbook/declaration-merging.html\r\n * https://www.typescriptlang.org/docs/handbook/mixins.html\r\n ********************************************************************************/\n\n/** @internal called to add drag over to support widgets being added externally */\n\ngridstack_1.GridStack.prototype._setupAcceptWidget = function () {\n  var _this = this;\n\n  // check if we need to disable things\n  if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n    GridStackDD.get().droppable(this.el, 'destroy');\n    return this;\n  } // vars shared across all methods\n\n\n  var gridPos;\n  var cellHeight, cellWidth;\n\n  var onDrag = function onDrag(event, el, helper) {\n    var node = el.gridstackNode;\n    if (!node) return;\n    helper = helper || el;\n    var rec = helper.getBoundingClientRect();\n    var left = rec.left - gridPos.left;\n    var top = rec.top - gridPos.top;\n    var ui = {\n      position: {\n        top: top,\n        left: left\n      }\n    };\n\n    if (node._temporaryRemoved) {\n      node.x = Math.max(0, Math.round(left / cellWidth));\n      node.y = Math.max(0, Math.round(top / cellHeight));\n      delete node.autoPosition;\n\n      _this.engine.nodeBoundFix(node); // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n\n\n      if (!_this.engine.willItFit(node)) {\n        node.autoPosition = true; // ignore x,y and try for any slot...\n\n        if (!_this.engine.willItFit(node)) {\n          GridStackDD.get().off(el, 'drag'); // stop calling us\n\n          return; // full grid or can't grow\n        }\n\n        if (node._willFitPos) {\n          // use the auto position instead #1687\n          utils_1.Utils.copyPos(node, node._willFitPos);\n          delete node._willFitPos;\n        }\n      } // re-use the existing node dragging method\n\n\n      _this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n    } else {\n      // re-use the existing node dragging that does so much of the collision detection\n      _this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n    }\n  };\n\n  GridStackDD.get().droppable(this.el, {\n    accept: function accept(el) {\n      var node = el.gridstackNode; // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n\n      if (node && node.grid === _this) return true;\n      if (!_this.opts.acceptWidgets) return false; // check for accept method or class matching\n\n      var canAccept = true;\n\n      if (typeof _this.opts.acceptWidgets === 'function') {\n        canAccept = _this.opts.acceptWidgets(el);\n      } else {\n        var selector = _this.opts.acceptWidgets === true ? '.grid-stack-item' : _this.opts.acceptWidgets;\n        canAccept = el.matches(selector);\n      } // finally check to make sure we actually have space left #1571\n\n\n      if (canAccept && node && _this.opts.maxRow) {\n        var n = {\n          w: node.w,\n          h: node.h,\n          minW: node.minW,\n          minH: node.minH\n        }; // only width/height matters and autoPosition\n\n        canAccept = _this.engine.willItFit(n);\n      }\n\n      return canAccept;\n    }\n  })\n  /**\r\n   * entering our grid area\r\n   */\n  .on(this.el, 'dropover', function (event, el, helper) {\n    var node = el.gridstackNode; // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n\n    if (node && node.grid === _this && !node._temporaryRemoved) {\n      // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n      return false; // prevent parent from receiving msg (which may be a grid as well)\n    } // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n\n\n    if (node && node.grid && node.grid !== _this && !node._temporaryRemoved) {\n      // TEST console.log('dropover without leave');\n      var otherGrid = node.grid;\n\n      otherGrid._leave(el, helper);\n    } // get grid screen coordinates and cell dimensions\n\n\n    var box = _this.el.getBoundingClientRect();\n\n    gridPos = {\n      top: box.top,\n      left: box.left\n    };\n    cellWidth = _this.cellWidth();\n    cellHeight = _this.getCellHeight(true); // load any element attributes if we don't have a node\n\n    if (!node) {\n      // @ts-ignore\n      node = _this._readAttr(el);\n    }\n\n    if (!node.grid) {\n      node._isExternal = true;\n      el.gridstackNode = node;\n    } // calculate the grid size based on element outer size\n\n\n    helper = helper || el;\n    var w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n    var h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1; // if the item came from another grid, make a copy and save the original info in case we go back there\n\n    if (node.grid && node.grid !== _this) {\n      // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n      // TEST console.log('dropover cloning node');\n      if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n\n      el.gridstackNode = node = Object.assign(Object.assign({}, node), {\n        w: w,\n        h: h,\n        grid: _this\n      });\n\n      _this.engine.cleanupNode(node).nodeBoundFix(node); // restore some internal fields we need after clearing them all\n\n\n      node._initDD = node._isExternal = // DOM needs to be re-parented on a drop\n      node._temporaryRemoved = true; // so it can be inserted onDrag below\n    } else {\n      node.w = w;\n      node.h = h;\n      node._temporaryRemoved = true; // so we can insert it\n    } // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n\n\n    _itemRemoving(node.el, false);\n\n    GridStackDD.get().on(el, 'drag', onDrag); // make sure this is called at least once when going fast #1578\n\n    onDrag(event, el, helper);\n    return false; // prevent parent from receiving msg (which may be a grid as well)\n  })\n  /**\r\n   * Leaving our grid area...\r\n   */\n  .on(this.el, 'dropout', function (event, el, helper) {\n    var node = el.gridstackNode; // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n    // so skip this one if we're not the active grid really..\n\n    if (!node.grid || node.grid === _this) {\n      _this._leave(el, helper);\n    }\n\n    return false; // prevent parent from receiving msg (which may be grid as well)\n  })\n  /**\r\n   * end - releasing the mouse\r\n   */\n  .on(this.el, 'drop', function (event, el, helper) {\n    var node = el.gridstackNode; // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n\n    if (node && node.grid === _this && !node._isExternal) return false;\n    var wasAdded = !!_this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n\n    _this.placeholder.remove(); // notify previous grid of removal\n    // TEST console.log('drop delete _gridstackNodeOrig')\n\n\n    var origNode = el._gridstackNodeOrig;\n    delete el._gridstackNodeOrig;\n\n    if (wasAdded && origNode && origNode.grid && origNode.grid !== _this) {\n      var oGrid = origNode.grid;\n      oGrid.engine.removedNodes.push(origNode);\n\n      oGrid._triggerRemoveEvent();\n    }\n\n    if (!node) return false; // use existing placeholder node as it's already in our list with drop location\n\n    if (wasAdded) {\n      _this.engine.cleanupNode(node); // removes all internal _xyz values\n\n\n      node.grid = _this;\n    }\n\n    GridStackDD.get().off(el, 'drag'); // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n    // as the helper will be nuked by jquery-ui otherwise\n\n    if (helper !== el) {\n      helper.remove();\n      el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n\n      if (wasAdded) {\n        el = el.cloneNode(true);\n      }\n    } else {\n      el.remove(); // reduce flicker as we change depth here, and size further down\n\n      GridStackDD.get().remove(el);\n    }\n\n    if (!wasAdded) return false;\n    el.gridstackNode = node;\n    node.el = el; // @ts-ignore\n\n    utils_1.Utils.copyPos(node, _this._readAttr(_this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n\n    utils_1.Utils.removePositioningStyles(el); // @ts-ignore\n\n    _this._writeAttr(el, node);\n\n    _this.el.appendChild(el); // @ts-ignore\n\n\n    _this._updateContainerHeight();\n\n    _this.engine.addedNodes.push(node); // @ts-ignore\n\n\n    _this._triggerAddEvent(); // @ts-ignore\n\n\n    _this._triggerChangeEvent();\n\n    _this.engine.endUpdate();\n\n    if (_this._gsEventHandler['dropped']) {\n      _this._gsEventHandler['dropped']({\n        type: 'dropped'\n      }, origNode && origNode.grid ? origNode : undefined, node);\n    } // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\n\n\n    window.setTimeout(function () {\n      // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\n      if (node.el && node.el.parentElement) {\n        _this._prepareDragDropByNode(node);\n      } else {\n        _this.engine.removeNode(node);\n      }\n    });\n    return false; // prevent parent from receiving msg (which may be grid as well)\n  });\n  return this;\n};\n/** @internal mark item for removal */\n\n\nfunction _itemRemoving(el, remove) {\n  var node = el ? el.gridstackNode : undefined;\n  if (!node || !node.grid) return;\n  remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n  remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\n}\n/** @internal called to setup a trash drop zone if the user specifies it */\n\n\ngridstack_1.GridStack.prototype._setupRemoveDrop = function () {\n  if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\n    var trashEl = document.querySelector(this.opts.removable);\n    if (!trashEl) return this; // only register ONE drop-over/dropout callback for the 'trash', and it will\n    // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n    // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n\n    if (!GridStackDD.get().isDroppable(trashEl)) {\n      GridStackDD.get().droppable(trashEl, this.opts.removableOptions).on(trashEl, 'dropover', function (event, el) {\n        return _itemRemoving(el, true);\n      }).on(trashEl, 'dropout', function (event, el) {\n        return _itemRemoving(el, false);\n      });\n    }\n  }\n\n  return this;\n};\n/**\r\n * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n * Called during GridStack.init() as options, but can also be called directly (last param are cached) in case the toolbar\r\n * is dynamically create and needs to change later.\r\n **/\n\n\ngridstack_1.GridStack.setupDragIn = function (_dragIn, _dragInOptions) {\n  var dragIn;\n  var dragInOptions;\n  var dragInDefaultOptions = {\n    revert: 'invalid',\n    handle: '.grid-stack-item-content',\n    scroll: false,\n    appendTo: 'body'\n  }; // cache in the passed in values (form grid init?) so they don't have to resend them each time\n\n  if (_dragIn) {\n    dragIn = _dragIn;\n    dragInOptions = Object.assign(Object.assign({}, dragInDefaultOptions), _dragInOptions || {});\n  }\n\n  if (typeof dragIn !== 'string') return;\n  var dd = GridStackDD.get();\n  utils_1.Utils.getElements(dragIn).forEach(function (el) {\n    if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n  });\n};\n/** @internal prepares the element for drag&drop **/\n\n\ngridstack_1.GridStack.prototype._prepareDragDropByNode = function (node) {\n  var _this2 = this;\n\n  var el = node.el;\n  var dd = GridStackDD.get(); // check for disabled grid first\n\n  if (this.opts.staticGrid || (node.noMove || this.opts.disableDrag) && (node.noResize || this.opts.disableResize)) {\n    if (node._initDD) {\n      dd.remove(el); // nukes everything instead of just disable, will add some styles back next\n\n      delete node._initDD;\n    }\n\n    el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\n\n    return this;\n  }\n\n  if (!node._initDD) {\n    // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n    var cellWidth;\n    var cellHeight;\n    /** called when item starts moving/resizing */\n\n    var onStartMoving = function onStartMoving(event, ui) {\n      // trigger any 'dragstart' / 'resizestart' manually\n      if (_this2._gsEventHandler[event.type]) {\n        _this2._gsEventHandler[event.type](event, event.target);\n      }\n\n      cellWidth = _this2.cellWidth();\n      cellHeight = _this2.getCellHeight(true); // force pixels for calculations\n\n      _this2._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n    };\n    /** called when item is being dragged/resized */\n\n\n    var dragOrResize = function dragOrResize(event, ui) {\n      _this2._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n    };\n    /** called when the item stops moving/resizing */\n\n\n    var onEndMoving = function onEndMoving(event) {\n      _this2.placeholder.remove();\n\n      delete node._moving;\n      delete node._lastTried; // if the item has moved to another grid, we're done here\n\n      var target = event.target;\n      if (!target.gridstackNode || target.gridstackNode.grid !== _this2) return;\n      node.el = target;\n\n      if (node._isAboutToRemove) {\n        var gridToNotify = el.gridstackNode.grid;\n\n        if (gridToNotify._gsEventHandler[event.type]) {\n          gridToNotify._gsEventHandler[event.type](event, target);\n        }\n\n        dd.remove(el);\n        gridToNotify.engine.removedNodes.push(node);\n\n        gridToNotify._triggerRemoveEvent(); // break circular links and remove DOM\n\n\n        delete el.gridstackNode;\n        delete node.el;\n        el.remove();\n      } else {\n        if (!node._temporaryRemoved) {\n          // move to new placeholder location\n          utils_1.Utils.removePositioningStyles(target); // @ts-ignore\n\n          _this2._writePosAttr(target, node);\n        } else {\n          // got removed - restore item back to before dragging position\n          utils_1.Utils.removePositioningStyles(target);\n          utils_1.Utils.copyPos(node, node._orig); // @ts-ignore\n\n          _this2._writePosAttr(target, node);\n\n          _this2.engine.addNode(node);\n        }\n\n        if (_this2._gsEventHandler[event.type]) {\n          _this2._gsEventHandler[event.type](event, target);\n        }\n      } // @ts-ignore\n\n\n      _this2._extraDragRow = 0; // @ts-ignore\n\n      _this2._updateContainerHeight(); // @ts-ignore\n\n\n      _this2._triggerChangeEvent();\n\n      _this2.engine.endUpdate();\n    };\n\n    dd.draggable(el, {\n      start: onStartMoving,\n      stop: onEndMoving,\n      drag: dragOrResize\n    }).resizable(el, {\n      start: onStartMoving,\n      stop: onEndMoving,\n      resize: dragOrResize\n    });\n    node._initDD = true; // we've set DD support now\n  } // finally fine tune move vs resize by disabling any part...\n\n\n  if (node.noMove || this.opts.disableDrag) {\n    dd.draggable(el, 'disable');\n    el.classList.add('ui-draggable-disabled');\n  } else {\n    dd.draggable(el, 'enable');\n    el.classList.remove('ui-draggable-disabled');\n  }\n\n  if (node.noResize || this.opts.disableResize) {\n    dd.resizable(el, 'disable');\n    el.classList.add('ui-resizable-disabled');\n  } else {\n    dd.resizable(el, 'enable');\n    el.classList.remove('ui-resizable-disabled');\n  }\n\n  return this;\n};\n/** @internal called when item is starting a drag/resize */\n\n\ngridstack_1.GridStack.prototype._onStartMoving = function (el, event, ui, node, cellWidth, cellHeight) {\n  this.engine.cleanNodes().beginUpdate(node); // @ts-ignore\n\n  this._writePosAttr(this.placeholder, node);\n\n  this.el.appendChild(this.placeholder); // TEST console.log('_onStartMoving placeholder')\n\n  node.el = this.placeholder;\n  node._lastUiPosition = ui.position;\n  node._prevYPix = ui.position.top;\n  node._moving = event.type === 'dragstart'; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n\n  delete node._lastTried;\n\n  if (event.type === 'dropover' && node._temporaryRemoved) {\n    // TEST console.log('engine.addNode x=' + node.x);\n    this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n\n    node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n  } // set the min/max resize info\n\n\n  this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n\n  if (event.type === 'resizestart') {\n    var dd = GridStackDD.get().resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1)).resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\n\n    if (node.maxW) {\n      dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW);\n    }\n\n    if (node.maxH) {\n      dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH);\n    }\n  }\n};\n/** @internal called when item leaving our area by either cursor dropout event\r\n * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n * our item to start with else restore prev node values from prev grid it came from.\r\n **/\n\n\ngridstack_1.GridStack.prototype._leave = function (el, helper) {\n  var node = el.gridstackNode;\n  if (!node) return;\n  GridStackDD.get().off(el, 'drag'); // no need to track while being outside\n  // this gets called when cursor leaves and shape is outside, so only do this once\n\n  if (node._temporaryRemoved) return;\n  node._temporaryRemoved = true;\n  this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n\n  node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n\n  if (this.opts.removable === true) {\n    // boolean vs a class string\n    // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n    _itemRemoving(el, true);\n  } // finally if item originally came from another grid, but left us, restore things back to prev info\n\n\n  if (el._gridstackNodeOrig) {\n    // TEST console.log('leave delete _gridstackNodeOrig')\n    el.gridstackNode = el._gridstackNodeOrig;\n    delete el._gridstackNodeOrig;\n  } else if (node._isExternal) {\n    // item came from outside (like a toolbar) so nuke any node info\n    delete node.el;\n    delete el.gridstackNode; // and restore all nodes back to original\n\n    this.engine.restoreInitial();\n  }\n};\n/** @internal called when item is being dragged/resized */\n\n\ngridstack_1.GridStack.prototype._dragOrResize = function (el, event, ui, node, cellWidth, cellHeight) {\n  var p = Object.assign({}, node._orig); // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n\n  var resizing;\n  var mLeft = this.opts.marginLeft,\n      mRight = this.opts.marginRight,\n      mTop = this.opts.marginTop,\n      mBottom = this.opts.marginBottom;\n\n  if (event.type === 'drag') {\n    if (node._temporaryRemoved) return; // handled by dropover\n\n    var distance = ui.position.top - node._prevYPix;\n    node._prevYPix = ui.position.top;\n    utils_1.Utils.updateScrollPosition(el, ui.position, distance); // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n\n    var left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n    var top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n    p.x = Math.round(left / cellWidth);\n    p.y = Math.round(top / cellHeight); // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n\n    var prev = this._extraDragRow;\n\n    if (this.engine.collide(node, p)) {\n      var row = this.getRow();\n      var extra = Math.max(0, p.y + node.h - row);\n\n      if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n        extra = Math.max(0, this.opts.maxRow - row);\n      } // @ts-ignore\n\n\n      this._extraDragRow = extra; // @ts-ignore\n    } else this._extraDragRow = 0; // @ts-ignore\n\n\n    if (this._extraDragRow !== prev) this._updateContainerHeight();\n    if (node.x === p.x && node.y === p.y) return; // skip same\n    // DON'T skip one we tried as we might have failed because of coverage <50% before\n    // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n  } else if (event.type === 'resize') {\n    if (p.x < 0) return; // Scrolling page if needed\n\n    utils_1.Utils.updateScrollResize(event, el, cellHeight); // get new size\n\n    p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n    p.h = Math.round((ui.size.height - mTop) / cellHeight);\n    if (node.w === p.w && node.h === p.h) return;\n    if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n    // if we size on left/top side this might move us, so get possible new position as well\n\n    var _left = ui.position.left + mLeft;\n\n    var _top = ui.position.top + mTop;\n\n    p.x = Math.round(_left / cellWidth);\n    p.y = Math.round(_top / cellHeight);\n    resizing = true;\n  }\n\n  node._lastTried = p; // set as last tried (will nuke if we go there)\n\n  var rect = {\n    x: ui.position.left + mLeft,\n    y: ui.position.top + mTop,\n    w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n    h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n  };\n\n  if (this.engine.moveNodeCheck(node, Object.assign(Object.assign({}, p), {\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    rect: rect\n  }))) {\n    node._lastUiPosition = ui.position;\n    this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n    delete node._skipDown;\n\n    if (resizing && node.subGrid) {\n      node.subGrid.onParentResize();\n    } // @ts-ignore\n\n\n    this._extraDragRow = 0; // @ts-ignore\n\n    this._updateContainerHeight();\n\n    var target = event.target; // @ts-ignore\n\n    this._writePosAttr(target, node);\n\n    if (this._gsEventHandler[event.type]) {\n      this._gsEventHandler[event.type](event, target);\n    }\n  }\n};\n/**\r\n * Enables/Disables moving.\r\n * @param els widget or selector to modify.\r\n * @param val if true widget will be draggable.\r\n */\n\n\ngridstack_1.GridStack.prototype.movable = function (els, val) {\n  var _this3 = this;\n\n  if (this.opts.staticGrid) return this; // can't move a static grid!\n\n  gridstack_1.GridStack.getElements(els).forEach(function (el) {\n    var node = el.gridstackNode;\n    if (!node) return;\n    if (val) delete node.noMove;else node.noMove = true;\n\n    _this3._prepareDragDropByNode(node); // init DD if need be, and adjust\n\n  });\n  return this;\n};\n/**\r\n * Enables/Disables resizing.\r\n * @param els  widget or selector to modify\r\n * @param val  if true widget will be resizable.\r\n */\n\n\ngridstack_1.GridStack.prototype.resizable = function (els, val) {\n  var _this4 = this;\n\n  if (this.opts.staticGrid) return this; // can't resize a static grid!\n\n  gridstack_1.GridStack.getElements(els).forEach(function (el) {\n    var node = el.gridstackNode;\n    if (!node) return;\n    if (val) delete node.noResize;else node.noResize = true;\n\n    _this4._prepareDragDropByNode(node); // init DD if need be, and adjust\n\n  });\n  return this;\n};\n/**\r\n  * Temporarily disables widgets moving/resizing.\r\n  * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n  * Note: no-op for static grid\r\n  * This is a shortcut for:\r\n  * @example\r\n  *  grid.enableMove(false);\r\n  *  grid.enableResize(false);\r\n  */\n\n\ngridstack_1.GridStack.prototype.disable = function () {\n  if (this.opts.staticGrid) return;\n  this.enableMove(false);\n  this.enableResize(false); // @ts-ignore\n\n  this._triggerEvent('disable');\n\n  return this;\n};\n/**\r\n  * Re-enables widgets moving/resizing - see disable().\r\n  * Note: no-op for static grid.\r\n  * This is a shortcut for:\r\n  * @example\r\n  *  grid.enableMove(true);\r\n  *  grid.enableResize(true);\r\n  */\n\n\ngridstack_1.GridStack.prototype.enable = function () {\n  if (this.opts.staticGrid) return;\n  this.enableMove(true);\n  this.enableResize(true); // @ts-ignore\n\n  this._triggerEvent('enable');\n\n  return this;\n};\n/** Enables/disables widget moving. No-op for static grids. */\n\n\ngridstack_1.GridStack.prototype.enableMove = function (doEnable) {\n  var _this5 = this;\n\n  if (this.opts.staticGrid) return this; // can't move a static grid!\n\n  this.opts.disableDrag = !doEnable; // FIRST before we update children as grid overrides #1658\n\n  this.engine.nodes.forEach(function (n) {\n    return _this5.movable(n.el, doEnable);\n  });\n  return this;\n};\n/** Enables/disables widget resizing. No-op for static grids. */\n\n\ngridstack_1.GridStack.prototype.enableResize = function (doEnable) {\n  var _this6 = this;\n\n  if (this.opts.staticGrid) return this; // can't size a static grid!\n\n  this.opts.disableResize = !doEnable; // FIRST before we update children as grid overrides #1658\n\n  this.engine.nodes.forEach(function (n) {\n    return _this6.resizable(n.el, doEnable);\n  });\n  return this;\n};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/gridstack-dd.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-base-impl.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-base-impl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-base-impl.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDBaseImplement = void 0;\n\nvar DDBaseImplement = /*#__PURE__*/function () {\n  function DDBaseImplement() {\n    _classCallCheck(this, DDBaseImplement);\n\n    /** @internal */\n    this._disabled = false;\n    /** @internal */\n\n    this._eventRegister = {};\n  }\n  /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */\n\n\n  _createClass(DDBaseImplement, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      this._eventRegister[event] = callback;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      delete this._eventRegister[event];\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this._disabled = false;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this._disabled = true;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      delete this._eventRegister;\n    }\n  }, {\n    key: \"triggerEvent\",\n    value: function triggerEvent(eventName, event) {\n      if (!this.disabled && this._eventRegister && this._eventRegister[eventName]) return this._eventRegister[eventName](event);\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this._disabled;\n    }\n  }]);\n\n  return DDBaseImplement;\n}();\n\nexports.DDBaseImplement = DDBaseImplement;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-base-impl.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-draggable.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-draggable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-draggable.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDDraggable = void 0;\n\nvar dd_manager_1 = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/h5/dd-manager.js\");\n\nvar dd_utils_1 = __webpack_require__(/*! ./dd-utils */ \"./node_modules/gridstack/dist/h5/dd-utils.js\");\n\nvar dd_base_impl_1 = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/h5/dd-base-impl.js\");\n\nvar DDDraggable = /*#__PURE__*/function (_dd_base_impl_1$DDBas) {\n  _inherits(DDDraggable, _dd_base_impl_1$DDBas);\n\n  var _super = _createSuper(DDDraggable);\n\n  function DDDraggable(el) {\n    var _this;\n\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DDDraggable);\n\n    _this = _super.call(this);\n    /** @internal */\n\n    _this.dragging = false;\n    /** @internal TODO: set to public as called by DDDroppable! */\n\n    _this.ui = function () {\n      var containmentEl = _this.el.parentElement;\n      var containmentRect = containmentEl.getBoundingClientRect();\n\n      var offset = _this.helper.getBoundingClientRect();\n\n      return {\n        position: {\n          top: offset.top - containmentRect.top,\n          left: offset.left - containmentRect.left\n        }\n        /* not used by GridStack for now...\r\n        helper: [this.helper], //The object arr representing the helper that's being dragged.\r\n        offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\r\n        */\n\n      };\n    };\n\n    _this.el = el;\n    _this.option = option; // get the element that is actually supposed to be dragged by\n\n    var className = option.handle.substring(1);\n    _this.dragEl = el.classList.contains(className) ? el : el.querySelector(option.handle) || el; // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n\n    _this._dragStart = _this._dragStart.bind(_assertThisInitialized(_this));\n    _this._drag = _this._drag.bind(_assertThisInitialized(_this));\n    _this._dragEnd = _this._dragEnd.bind(_assertThisInitialized(_this));\n\n    _this.enable();\n\n    return _this;\n  }\n\n  _createClass(DDDraggable, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      _get(_getPrototypeOf(DDDraggable.prototype), \"on\", this).call(this, event, callback);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      _get(_getPrototypeOf(DDDraggable.prototype), \"off\", this).call(this, event);\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      _get(_getPrototypeOf(DDDraggable.prototype), \"enable\", this).call(this);\n\n      this.dragEl.draggable = true;\n      this.dragEl.addEventListener('dragstart', this._dragStart);\n      this.el.classList.remove('ui-draggable-disabled');\n      this.el.classList.add('ui-draggable');\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var forDestroy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      _get(_getPrototypeOf(DDDraggable.prototype), \"disable\", this).call(this);\n\n      this.dragEl.removeAttribute('draggable');\n      this.dragEl.removeEventListener('dragstart', this._dragStart);\n      this.el.classList.remove('ui-draggable');\n      if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.dragging) {\n        // Destroy while dragging should remove dragend listener and manually trigger\n        // dragend, otherwise dragEnd can't perform dragstop because eventRegistry is\n        // destroyed.\n        this._dragEnd({});\n      }\n\n      this.disable(true);\n      delete this.el;\n      delete this.helper;\n      delete this.option;\n\n      _get(_getPrototypeOf(DDDraggable.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"updateOption\",\n    value: function updateOption(opts) {\n      var _this2 = this;\n\n      Object.keys(opts).forEach(function (key) {\n        return _this2.option[key] = opts[key];\n      });\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_dragStart\",\n    value: function _dragStart(event) {\n      var _this3 = this;\n\n      dd_manager_1.DDManager.dragElement = this;\n      this.helper = this._createHelper(event);\n\n      this._setupHelperContainmentStyle();\n\n      this.dragOffset = this._getDragOffset(event, this.el, this.helperContainment);\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        target: this.el,\n        type: 'dragstart'\n      });\n\n      if (this.helper !== this.el) {\n        this._setupDragFollowNodeNotifyStart(ev); // immediately set external helper initial position to avoid flickering behavior and unnecessary looping in `_packNodes()`\n\n\n        this._dragFollow(event);\n      } else {\n        this.dragFollowTimer = window.setTimeout(function () {\n          delete _this3.dragFollowTimer;\n\n          _this3._setupDragFollowNodeNotifyStart(ev);\n        }, 0);\n      }\n\n      this._cancelDragGhost(event);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupDragFollowNodeNotifyStart\",\n    value: function _setupDragFollowNodeNotifyStart(ev) {\n      this._setupHelperStyle();\n\n      document.addEventListener('dragover', this._drag, DDDraggable.dragEventListenerOption);\n      this.dragEl.addEventListener('dragend', this._dragEnd);\n\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n\n      this.dragging = true;\n      this.helper.classList.add('ui-draggable-dragging');\n      this.triggerEvent('dragstart', ev);\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_drag\",\n    value: function _drag(event) {\n      // Safari: prevent default to allow drop to happen instead of reverting back (with animation) and delaying dragend #1541\n      // https://stackoverflow.com/questions/61760755/how-to-fire-dragend-event-immediately\n      event.preventDefault();\n\n      this._dragFollow(event);\n\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        target: this.el,\n        type: 'drag'\n      });\n\n      if (this.option.drag) {\n        this.option.drag(ev, this.ui());\n      }\n\n      this.triggerEvent('drag', ev);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_dragEnd\",\n    value: function _dragEnd(event) {\n      if (this.dragFollowTimer) {\n        clearTimeout(this.dragFollowTimer);\n        delete this.dragFollowTimer;\n        return;\n      } else {\n        if (this.paintTimer) {\n          cancelAnimationFrame(this.paintTimer);\n        }\n\n        document.removeEventListener('dragover', this._drag, DDDraggable.dragEventListenerOption);\n        this.dragEl.removeEventListener('dragend', this._dragEnd);\n      }\n\n      this.dragging = false;\n      this.helper.classList.remove('ui-draggable-dragging');\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n\n      if (this.helper === this.el) {\n        this._removeHelperStyle();\n      } else {\n        this.helper.remove();\n      }\n\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        target: this.el,\n        type: 'dragstop'\n      });\n\n      if (this.option.stop) {\n        this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n      }\n\n      this.triggerEvent('dragstop', ev);\n      delete dd_manager_1.DDManager.dragElement;\n      delete this.helper;\n    }\n    /** @internal create a clone copy (or user defined method) of the original drag item if set */\n\n  }, {\n    key: \"_createHelper\",\n    value: function _createHelper(event) {\n      var _this4 = this;\n\n      var helper = this.el;\n\n      if (typeof this.option.helper === 'function') {\n        helper = this.option.helper(event);\n      } else if (this.option.helper === 'clone') {\n        helper = dd_utils_1.DDUtils.clone(this.el);\n      }\n\n      if (!document.body.contains(helper)) {\n        dd_utils_1.DDUtils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentNode : this.option.appendTo);\n      }\n\n      if (helper === this.el) {\n        this.dragElementOriginStyle = DDDraggable.originStyleProp.map(function (prop) {\n          return _this4.el.style[prop];\n        });\n      }\n\n      return helper;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupHelperStyle\",\n    value: function _setupHelperStyle() {\n      var _this5 = this;\n\n      this.helper.style.pointerEvents = 'none';\n      this.helper.style.width = this.dragOffset.width + 'px';\n      this.helper.style.height = this.dragOffset.height + 'px';\n      this.helper.style.willChange = 'left, top';\n      this.helper.style.transition = 'none'; // show up instantly\n\n      this.helper.style.position = this.option.basePosition || DDDraggable.basePosition;\n      this.helper.style.zIndex = '1000';\n      setTimeout(function () {\n        if (_this5.helper) {\n          _this5.helper.style.transition = null; // recover animation\n        }\n      }, 0);\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_removeHelperStyle\",\n    value: function _removeHelperStyle() {\n      var _this6 = this;\n\n      // don't bother restoring styles if we're gonna remove anyway...\n      var node = this.helper ? this.helper.gridstackNode : undefined;\n\n      if (!node || !node._isAboutToRemove) {\n        DDDraggable.originStyleProp.forEach(function (prop) {\n          _this6.helper.style[prop] = _this6.dragElementOriginStyle[prop] || null;\n        });\n      }\n\n      delete this.dragElementOriginStyle;\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_dragFollow\",\n    value: function _dragFollow(event) {\n      var _this7 = this;\n\n      if (this.paintTimer) {\n        cancelAnimationFrame(this.paintTimer);\n      }\n\n      this.paintTimer = requestAnimationFrame(function () {\n        delete _this7.paintTimer;\n        var offset = _this7.dragOffset;\n        var containmentRect = {\n          left: 0,\n          top: 0\n        };\n\n        if (_this7.helper.style.position === 'absolute') {\n          var _this7$helperContainm = _this7.helperContainment.getBoundingClientRect(),\n              left = _this7$helperContainm.left,\n              top = _this7$helperContainm.top;\n\n          containmentRect = {\n            left: left,\n            top: top\n          };\n        }\n\n        _this7.helper.style.left = event.clientX + offset.offsetLeft - containmentRect.left + 'px';\n        _this7.helper.style.top = event.clientY + offset.offsetTop - containmentRect.top + 'px';\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupHelperContainmentStyle\",\n    value: function _setupHelperContainmentStyle() {\n      this.helperContainment = this.helper.parentElement;\n\n      if (this.option.basePosition !== 'fixed') {\n        this.parentOriginStylePosition = this.helperContainment.style.position;\n\n        if (window.getComputedStyle(this.helperContainment).position.match(/static/)) {\n          this.helperContainment.style.position = 'relative';\n        }\n      }\n\n      return this;\n    }\n    /** @internal prevent the default gost image to be created (which has wrongas we move the helper/element instead\r\n     * (legacy jquery UI code updates the top/left of the item).\r\n     * TODO: maybe use mouse event instead of HTML5 drag as we have to work around it anyway, or change code to not update\r\n     * the actual grid-item but move the gost image around (and special case jq version) ?\r\n     **/\n\n  }, {\n    key: \"_cancelDragGhost\",\n    value: function _cancelDragGhost(e) {\n      /* doesn't seem to do anything...\r\n      let t = e.dataTransfer;\r\n      t.effectAllowed = 'none';\r\n      t.dropEffect = 'none';\r\n      t.setData('text', '');\r\n      */\n      // NOTE: according to spec (and required by Safari see #1540) the image has to be visible in the browser (in dom and not hidden) so make it a 1px div\n      var img = document.createElement('div');\n      img.style.width = '1px';\n      img.style.height = '1px';\n      img.style.position = 'fixed'; // prevent unwanted scrollbar\n\n      document.body.appendChild(img);\n      e.dataTransfer.setDragImage(img, 0, 0);\n      setTimeout(function () {\n        return document.body.removeChild(img);\n      }); // nuke once drag had a chance to grab this 'image'\n\n      e.stopPropagation();\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getDragOffset\",\n    value: function _getDragOffset(event, el, parent) {\n      // in case ancestor has transform/perspective css properties that change the viewpoint\n      var xformOffsetX = 0;\n      var xformOffsetY = 0;\n\n      if (parent) {\n        var testEl = document.createElement('div');\n        dd_utils_1.DDUtils.addElStyles(testEl, {\n          opacity: '0',\n          position: 'fixed',\n          top: 0 + 'px',\n          left: 0 + 'px',\n          width: '1px',\n          height: '1px',\n          zIndex: '-999999'\n        });\n        parent.appendChild(testEl);\n        var testElPosition = testEl.getBoundingClientRect();\n        parent.removeChild(testEl);\n        xformOffsetX = testElPosition.left;\n        xformOffsetY = testElPosition.top; // TODO: scale ?\n      }\n\n      var targetOffset = el.getBoundingClientRect();\n      return {\n        left: targetOffset.left,\n        top: targetOffset.top,\n        offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n        offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n        width: targetOffset.width,\n        height: targetOffset.height\n      };\n    }\n  }]);\n\n  return DDDraggable;\n}(dd_base_impl_1.DDBaseImplement);\n\nexports.DDDraggable = DDDraggable;\n/** @internal */\n\nDDDraggable.basePosition = 'absolute';\n/** @internal #1541 can't have {passive: true} on Safari as otherwise it reverts animate back to old location on drop */\n\nDDDraggable.dragEventListenerOption = true; // DDUtils.isEventSupportPassiveOption ? { capture: true, passive: true } : true;\n\n/** @internal */\n\nDDDraggable.originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'opacity', 'zIndex', 'width', 'height', 'willChange'];\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-draggable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-droppable.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-droppable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-droppable.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDDroppable = void 0;\n\nvar dd_manager_1 = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/h5/dd-manager.js\");\n\nvar dd_base_impl_1 = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/h5/dd-base-impl.js\");\n\nvar dd_utils_1 = __webpack_require__(/*! ./dd-utils */ \"./node_modules/gridstack/dist/h5/dd-utils.js\");\n\nvar DDDroppable = /*#__PURE__*/function (_dd_base_impl_1$DDBas) {\n  _inherits(DDDroppable, _dd_base_impl_1$DDBas);\n\n  var _super = _createSuper(DDDroppable);\n\n  function DDDroppable(el) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DDDroppable);\n\n    _this = _super.call(this);\n    _this.el = el;\n    _this.option = opts; // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n\n    _this._dragEnter = _this._dragEnter.bind(_assertThisInitialized(_this));\n    _this._dragOver = _this._dragOver.bind(_assertThisInitialized(_this));\n    _this._dragLeave = _this._dragLeave.bind(_assertThisInitialized(_this));\n    _this._drop = _this._drop.bind(_assertThisInitialized(_this));\n\n    _this.el.classList.add('ui-droppable');\n\n    _this.el.addEventListener('dragenter', _this._dragEnter);\n\n    _this._setupAccept();\n\n    return _this;\n  }\n\n  _createClass(DDDroppable, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      _get(_getPrototypeOf(DDDroppable.prototype), \"on\", this).call(this, event, callback);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      _get(_getPrototypeOf(DDDroppable.prototype), \"off\", this).call(this, event);\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      if (!this.disabled) return;\n\n      _get(_getPrototypeOf(DDDroppable.prototype), \"enable\", this).call(this);\n\n      this.el.classList.remove('ui-droppable-disabled');\n      this.el.addEventListener('dragenter', this._dragEnter);\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var forDestroy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.disabled) return;\n\n      _get(_getPrototypeOf(DDDroppable.prototype), \"disable\", this).call(this);\n\n      if (!forDestroy) this.el.classList.add('ui-droppable-disabled');\n      this.el.removeEventListener('dragenter', this._dragEnter);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.moving) {\n        this._removeLeaveCallbacks();\n      }\n\n      this.disable(true);\n      this.el.classList.remove('ui-droppable');\n      this.el.classList.remove('ui-droppable-disabled');\n      delete this.moving;\n\n      _get(_getPrototypeOf(DDDroppable.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"updateOption\",\n    value: function updateOption(opts) {\n      var _this2 = this;\n\n      Object.keys(opts).forEach(function (key) {\n        return _this2.option[key] = opts[key];\n      });\n\n      this._setupAccept();\n\n      return this;\n    }\n    /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */\n\n  }, {\n    key: \"_dragEnter\",\n    value: function _dragEnter(event) {\n      if (!this._canDrop()) return;\n      event.preventDefault();\n      if (this.moving) return; // ignore multiple 'dragenter' as we go over existing items\n\n      this.moving = true;\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        target: this.el,\n        type: 'dropover'\n      });\n\n      if (this.option.over) {\n        this.option.over(ev, this._ui(dd_manager_1.DDManager.dragElement));\n      }\n\n      this.triggerEvent('dropover', ev);\n      this.el.addEventListener('dragover', this._dragOver);\n      this.el.addEventListener('drop', this._drop);\n      this.el.addEventListener('dragleave', this._dragLeave);\n      this.el.classList.add('ui-droppable-over');\n    }\n    /** @internal called when an moving to drop item is being dragged over - do nothing but eat the event */\n\n  }, {\n    key: \"_dragOver\",\n    value: function _dragOver(event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    /** @internal called when the item is leaving our area, stop tracking if we had moving item */\n\n  }, {\n    key: \"_dragLeave\",\n    value: function _dragLeave(event) {\n      // ignore leave events on our children (get when starting to drag our items)\n      // Note: Safari Mac has null relatedTarget which causes #1684 so check if DragEvent is inside the grid instead\n      if (!event.relatedTarget) {\n        var _this$el$getBoundingC = this.el.getBoundingClientRect(),\n            bottom = _this$el$getBoundingC.bottom,\n            left = _this$el$getBoundingC.left,\n            right = _this$el$getBoundingC.right,\n            top = _this$el$getBoundingC.top;\n\n        if (event.x < right && event.x > left && event.y < bottom && event.y > top) return;\n      } else if (this.el.contains(event.relatedTarget)) return;\n\n      this._removeLeaveCallbacks();\n\n      if (this.moving) {\n        event.preventDefault();\n        var ev = dd_utils_1.DDUtils.initEvent(event, {\n          target: this.el,\n          type: 'dropout'\n        });\n\n        if (this.option.out) {\n          this.option.out(ev, this._ui(dd_manager_1.DDManager.dragElement));\n        }\n\n        this.triggerEvent('dropout', ev);\n      }\n\n      delete this.moving;\n    }\n    /** @internal item is being dropped on us - call the client drop event */\n\n  }, {\n    key: \"_drop\",\n    value: function _drop(event) {\n      if (!this.moving) return; // should not have received event...\n\n      event.preventDefault();\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        target: this.el,\n        type: 'drop'\n      });\n\n      if (this.option.drop) {\n        this.option.drop(ev, this._ui(dd_manager_1.DDManager.dragElement));\n      }\n\n      this.triggerEvent('drop', ev);\n\n      this._removeLeaveCallbacks();\n\n      delete this.moving;\n    }\n    /** @internal called to remove callbacks when leaving or dropping */\n\n  }, {\n    key: \"_removeLeaveCallbacks\",\n    value: function _removeLeaveCallbacks() {\n      this.el.removeEventListener('dragleave', this._dragLeave);\n      this.el.classList.remove('ui-droppable-over');\n\n      if (this.moving) {\n        this.el.removeEventListener('dragover', this._dragOver);\n        this.el.removeEventListener('drop', this._drop);\n      } // Note: this.moving is reset by callee of this routine to control the flow\n\n    }\n    /** @internal */\n\n  }, {\n    key: \"_canDrop\",\n    value: function _canDrop() {\n      return dd_manager_1.DDManager.dragElement && (!this.accept || this.accept(dd_manager_1.DDManager.dragElement.el));\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupAccept\",\n    value: function _setupAccept() {\n      var _this3 = this;\n\n      if (this.option.accept && typeof this.option.accept === 'string') {\n        this.accept = function (el) {\n          return el.matches(_this3.option.accept);\n        };\n      } else {\n        this.accept = this.option.accept;\n      }\n\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_ui\",\n    value: function _ui(drag) {\n      return Object.assign({\n        draggable: drag.el\n      }, drag.ui());\n    }\n  }]);\n\n  return DDDroppable;\n}(dd_base_impl_1.DDBaseImplement);\n\nexports.DDDroppable = DDDroppable;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-droppable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-element.js":
/*!******************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-element.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-elements.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDElement = void 0;\n\nvar dd_resizable_1 = __webpack_require__(/*! ./dd-resizable */ \"./node_modules/gridstack/dist/h5/dd-resizable.js\");\n\nvar dd_draggable_1 = __webpack_require__(/*! ./dd-draggable */ \"./node_modules/gridstack/dist/h5/dd-draggable.js\");\n\nvar dd_droppable_1 = __webpack_require__(/*! ./dd-droppable */ \"./node_modules/gridstack/dist/h5/dd-droppable.js\");\n\nvar DDElement = /*#__PURE__*/function () {\n  function DDElement(el) {\n    _classCallCheck(this, DDElement);\n\n    this.el = el;\n  }\n\n  _createClass(DDElement, [{\n    key: \"on\",\n    value: function on(eventName, callback) {\n      if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n        this.ddDraggable.on(eventName, callback);\n      } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n        this.ddDroppable.on(eventName, callback);\n      } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n        this.ddResizable.on(eventName, callback);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(eventName) {\n      if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n        this.ddDraggable.off(eventName);\n      } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n        this.ddDroppable.off(eventName);\n      } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n        this.ddResizable.off(eventName);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setupDraggable\",\n    value: function setupDraggable(opts) {\n      if (!this.ddDraggable) {\n        this.ddDraggable = new dd_draggable_1.DDDraggable(this.el, opts);\n      } else {\n        this.ddDraggable.updateOption(opts);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"cleanDraggable\",\n    value: function cleanDraggable() {\n      if (this.ddDraggable) {\n        this.ddDraggable.destroy();\n        delete this.ddDraggable;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setupResizable\",\n    value: function setupResizable(opts) {\n      if (!this.ddResizable) {\n        this.ddResizable = new dd_resizable_1.DDResizable(this.el, opts);\n      } else {\n        this.ddResizable.updateOption(opts);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"cleanResizable\",\n    value: function cleanResizable() {\n      if (this.ddResizable) {\n        this.ddResizable.destroy();\n        delete this.ddResizable;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setupDroppable\",\n    value: function setupDroppable(opts) {\n      if (!this.ddDroppable) {\n        this.ddDroppable = new dd_droppable_1.DDDroppable(this.el, opts);\n      } else {\n        this.ddDroppable.updateOption(opts);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"cleanDroppable\",\n    value: function cleanDroppable() {\n      if (this.ddDroppable) {\n        this.ddDroppable.destroy();\n        delete this.ddDroppable;\n      }\n\n      return this;\n    }\n  }], [{\n    key: \"init\",\n    value: function init(el) {\n      if (!el.ddElement) {\n        el.ddElement = new DDElement(el);\n      }\n\n      return el.ddElement;\n    }\n  }]);\n\n  return DDElement;\n}();\n\nexports.DDElement = DDElement;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-element.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-manager.js":
/*!******************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-manager.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDManager = void 0;\n\nvar DDManager = function DDManager() {\n  _classCallCheck(this, DDManager);\n};\n\nexports.DDManager = DDManager;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-manager.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-resizable-handle.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-resizable-handle.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-resizable-handle.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDResizableHandle = void 0;\n\nvar DDResizableHandle = /*#__PURE__*/function () {\n  function DDResizableHandle(host, direction, option) {\n    _classCallCheck(this, DDResizableHandle);\n\n    /** @internal true after we've moved enough pixels to start a resize */\n    this.moving = false;\n    this.host = host;\n    this.dir = direction;\n    this.option = option; // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n\n    this._init();\n  }\n  /** @internal */\n\n\n  _createClass(DDResizableHandle, [{\n    key: \"_init\",\n    value: function _init() {\n      var el = document.createElement('div');\n      el.classList.add('ui-resizable-handle');\n      el.classList.add(\"\".concat(DDResizableHandle.prefix).concat(this.dir));\n      el.style.zIndex = '100';\n      el.style.userSelect = 'none';\n      this.el = el;\n      this.host.appendChild(this.el);\n      this.el.addEventListener('mousedown', this._mouseDown);\n      return this;\n    }\n    /** call this when resize handle needs to be removed and cleaned up */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.moving) this._mouseUp(this.mouseDownEvent);\n      this.el.removeEventListener('mousedown', this._mouseDown);\n      this.host.removeChild(this.el);\n      delete this.el;\n      delete this.host;\n      return this;\n    }\n    /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */\n\n  }, {\n    key: \"_mouseDown\",\n    value: function _mouseDown(e) {\n      e.preventDefault();\n      this.mouseDownEvent = e;\n      document.addEventListener('mousemove', this._mouseMove, true); // capture, not bubble\n\n      document.addEventListener('mouseup', this._mouseUp);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_mouseMove\",\n    value: function _mouseMove(e) {\n      var s = this.mouseDownEvent; // don't start unless we've moved at least 3 pixels\n\n      if (!this.moving && Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {\n        this.moving = true;\n\n        this._triggerEvent('start', this.mouseDownEvent);\n      } else if (this.moving) {\n        this._triggerEvent('move', e);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_mouseUp\",\n    value: function _mouseUp(e) {\n      if (this.moving) {\n        this._triggerEvent('stop', e);\n      }\n\n      document.removeEventListener('mousemove', this._mouseMove, true);\n      document.removeEventListener('mouseup', this._mouseUp);\n      delete this.moving;\n      delete this.mouseDownEvent;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_triggerEvent\",\n    value: function _triggerEvent(name, event) {\n      if (this.option[name]) this.option[name](event);\n      return this;\n    }\n  }]);\n\n  return DDResizableHandle;\n}();\n\nexports.DDResizableHandle = DDResizableHandle;\n/** @internal */\n\nDDResizableHandle.prefix = 'ui-resizable-';\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-resizable-handle.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-resizable.js":
/*!********************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-resizable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * dd-resizable.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDResizable = void 0;\n\nvar dd_resizable_handle_1 = __webpack_require__(/*! ./dd-resizable-handle */ \"./node_modules/gridstack/dist/h5/dd-resizable-handle.js\");\n\nvar dd_base_impl_1 = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/h5/dd-base-impl.js\");\n\nvar dd_utils_1 = __webpack_require__(/*! ./dd-utils */ \"./node_modules/gridstack/dist/h5/dd-utils.js\");\n\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/gridstack/dist/utils.js\");\n\nvar DDResizable = /*#__PURE__*/function (_dd_base_impl_1$DDBas) {\n  _inherits(DDResizable, _dd_base_impl_1$DDBas);\n\n  var _super = _createSuper(DDResizable);\n\n  function DDResizable(el) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DDResizable);\n\n    _this = _super.call(this);\n    /** @internal */\n\n    _this._showHandlers = function () {\n      _this.el.classList.remove('ui-resizable-autohide');\n    };\n    /** @internal */\n\n\n    _this._hideHandlers = function () {\n      _this.el.classList.add('ui-resizable-autohide');\n    };\n    /** @internal */\n\n\n    _this._ui = function () {\n      var containmentEl = _this.el.parentElement;\n      var containmentRect = containmentEl.getBoundingClientRect();\n      var newRect = {\n        width: _this.originalRect.width,\n        height: _this.originalRect.height + _this.scrolled,\n        left: _this.originalRect.left,\n        top: _this.originalRect.top - _this.scrolled\n      };\n      var rect = _this.temporalRect || newRect;\n      return {\n        position: {\n          left: rect.left - containmentRect.left,\n          top: rect.top - containmentRect.top\n        },\n        size: {\n          width: rect.width,\n          height: rect.height\n        }\n        /* Gridstack ONLY needs position set above... keep around in case.\r\n        element: [this.el], // The object representing the element to be resized\r\n        helper: [], // TODO: not support yet - The object representing the helper that's being resized\r\n        originalElement: [this.el],// we don't wrap here, so simplify as this.el //The object representing the original element before it is wrapped\r\n        originalPosition: { // The position represented as { left, top } before the resizable is resized\r\n          left: this.originalRect.left - containmentRect.left,\r\n          top: this.originalRect.top - containmentRect.top\r\n        },\r\n        originalSize: { // The size represented as { width, height } before the resizable is resized\r\n          width: this.originalRect.width,\r\n          height: this.originalRect.height\r\n        }\r\n        */\n\n      };\n    };\n\n    _this.el = el;\n    _this.option = opts;\n\n    _this.enable();\n\n    _this._setupAutoHide();\n\n    _this._setupHandlers();\n\n    return _this;\n  }\n\n  _createClass(DDResizable, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      _get(_getPrototypeOf(DDResizable.prototype), \"on\", this).call(this, event, callback);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      _get(_getPrototypeOf(DDResizable.prototype), \"off\", this).call(this, event);\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      _get(_getPrototypeOf(DDResizable.prototype), \"enable\", this).call(this);\n\n      this.el.classList.add('ui-resizable');\n      this.el.classList.remove('ui-resizable-disabled');\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      _get(_getPrototypeOf(DDResizable.prototype), \"disable\", this).call(this);\n\n      this.el.classList.add('ui-resizable-disabled');\n      this.el.classList.remove('ui-resizable');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._removeHandlers();\n\n      if (this.option.autoHide) {\n        this.el.removeEventListener('mouseover', this._showHandlers);\n        this.el.removeEventListener('mouseout', this._hideHandlers);\n      }\n\n      this.el.classList.remove('ui-resizable');\n      delete this.el;\n\n      _get(_getPrototypeOf(DDResizable.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"updateOption\",\n    value: function updateOption(opts) {\n      var _this2 = this;\n\n      var updateHandles = opts.handles && opts.handles !== this.option.handles;\n      var updateAutoHide = opts.autoHide && opts.autoHide !== this.option.autoHide;\n      Object.keys(opts).forEach(function (key) {\n        return _this2.option[key] = opts[key];\n      });\n\n      if (updateHandles) {\n        this._removeHandlers();\n\n        this._setupHandlers();\n      }\n\n      if (updateAutoHide) {\n        this._setupAutoHide();\n      }\n\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupAutoHide\",\n    value: function _setupAutoHide() {\n      if (this.option.autoHide) {\n        this.el.classList.add('ui-resizable-autohide'); // use mouseover/mouseout instead of mouseenter/mouseleave to get better performance;\n\n        this.el.addEventListener('mouseover', this._showHandlers);\n        this.el.addEventListener('mouseout', this._hideHandlers);\n      } else {\n        this.el.classList.remove('ui-resizable-autohide');\n        this.el.removeEventListener('mouseover', this._showHandlers);\n        this.el.removeEventListener('mouseout', this._hideHandlers);\n      }\n\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupHandlers\",\n    value: function _setupHandlers() {\n      var _this3 = this;\n\n      var handlerDirection = this.option.handles || 'e,s,se';\n\n      if (handlerDirection === 'all') {\n        handlerDirection = 'n,e,s,w,se,sw,ne,nw';\n      }\n\n      this.handlers = handlerDirection.split(',').map(function (dir) {\n        return dir.trim();\n      }).map(function (dir) {\n        return new dd_resizable_handle_1.DDResizableHandle(_this3.el, dir, {\n          start: function start(event) {\n            _this3._resizeStart(event);\n          },\n          stop: function stop(event) {\n            _this3._resizeStop(event);\n          },\n          move: function move(event) {\n            _this3._resizing(event, dir);\n          }\n        });\n      });\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_resizeStart\",\n    value: function _resizeStart(event) {\n      this.originalRect = this.el.getBoundingClientRect();\n      this.scrollEl = utils_1.Utils.getScrollElement(this.el);\n      this.scrollY = this.scrollEl.scrollTop;\n      this.startEvent = event;\n\n      this._setupHelper();\n\n      this._applyChange();\n\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        type: 'resizestart',\n        target: this.el\n      });\n\n      if (this.option.start) {\n        this.option.start(ev, this._ui());\n      }\n\n      this.el.classList.add('ui-resizable-resizing');\n      this.triggerEvent('resizestart', ev);\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_resizing\",\n    value: function _resizing(event, dir) {\n      this.scrolled = this.scrollEl.scrollTop - this.scrollY;\n      this.temporalRect = this._getChange(event, dir);\n\n      this._applyChange();\n\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        type: 'resize',\n        target: this.el\n      });\n\n      if (this.option.resize) {\n        this.option.resize(ev, this._ui());\n      }\n\n      this.triggerEvent('resize', ev);\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_resizeStop\",\n    value: function _resizeStop(event) {\n      var ev = dd_utils_1.DDUtils.initEvent(event, {\n        type: 'resizestop',\n        target: this.el\n      });\n\n      if (this.option.stop) {\n        this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n      }\n\n      this.el.classList.remove('ui-resizable-resizing');\n      this.triggerEvent('resizestop', ev);\n\n      this._cleanHelper();\n\n      delete this.startEvent;\n      delete this.originalRect;\n      delete this.temporalRect;\n      delete this.scrollY;\n      delete this.scrolled;\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setupHelper\",\n    value: function _setupHelper() {\n      var _this4 = this;\n\n      this.elOriginStyleVal = DDResizable._originStyleProp.map(function (prop) {\n        return _this4.el.style[prop];\n      });\n      this.parentOriginStylePosition = this.el.parentElement.style.position;\n\n      if (window.getComputedStyle(this.el.parentElement).position.match(/static/)) {\n        this.el.parentElement.style.position = 'relative';\n      }\n\n      this.el.style.position = this.option.basePosition || 'absolute'; // or 'fixed'\n\n      this.el.style.opacity = '0.8';\n      this.el.style.zIndex = '1000';\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_cleanHelper\",\n    value: function _cleanHelper() {\n      var _this5 = this;\n\n      DDResizable._originStyleProp.forEach(function (prop, i) {\n        _this5.el.style[prop] = _this5.elOriginStyleVal[i] || null;\n      });\n\n      this.el.parentElement.style.position = this.parentOriginStylePosition || null;\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getChange\",\n    value: function _getChange(event, dir) {\n      var oEvent = this.startEvent;\n      var newRect = {\n        width: this.originalRect.width,\n        height: this.originalRect.height + this.scrolled,\n        left: this.originalRect.left,\n        top: this.originalRect.top - this.scrolled\n      };\n      var offsetX = event.clientX - oEvent.clientX;\n      var offsetY = event.clientY - oEvent.clientY;\n\n      if (dir.indexOf('e') > -1) {\n        newRect.width += offsetX;\n      } else if (dir.indexOf('w') > -1) {\n        newRect.width -= offsetX;\n        newRect.left += offsetX;\n      }\n\n      if (dir.indexOf('s') > -1) {\n        newRect.height += offsetY;\n      } else if (dir.indexOf('n') > -1) {\n        newRect.height -= offsetY;\n        newRect.top += offsetY;\n      }\n\n      var constrain = this._constrainSize(newRect.width, newRect.height);\n\n      if (Math.round(newRect.width) !== Math.round(constrain.width)) {\n        // round to ignore slight round-off errors\n        if (dir.indexOf('w') > -1) {\n          newRect.left += newRect.width - constrain.width;\n        }\n\n        newRect.width = constrain.width;\n      }\n\n      if (Math.round(newRect.height) !== Math.round(constrain.height)) {\n        if (dir.indexOf('n') > -1) {\n          newRect.top += newRect.height - constrain.height;\n        }\n\n        newRect.height = constrain.height;\n      }\n\n      return newRect;\n    }\n    /** @internal constrain the size to the set min/max values */\n\n  }, {\n    key: \"_constrainSize\",\n    value: function _constrainSize(oWidth, oHeight) {\n      var maxWidth = this.option.maxWidth || Number.MAX_SAFE_INTEGER;\n      var minWidth = this.option.minWidth || oWidth;\n      var maxHeight = this.option.maxHeight || Number.MAX_SAFE_INTEGER;\n      var minHeight = this.option.minHeight || oHeight;\n      var width = Math.min(maxWidth, Math.max(minWidth, oWidth));\n      var height = Math.min(maxHeight, Math.max(minHeight, oHeight));\n      return {\n        width: width,\n        height: height\n      };\n    }\n    /** @internal */\n\n  }, {\n    key: \"_applyChange\",\n    value: function _applyChange() {\n      var _this6 = this;\n\n      var containmentRect = {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      };\n\n      if (this.el.style.position === 'absolute') {\n        var containmentEl = this.el.parentElement;\n\n        var _containmentEl$getBou = containmentEl.getBoundingClientRect(),\n            left = _containmentEl$getBou.left,\n            top = _containmentEl$getBou.top;\n\n        containmentRect = {\n          left: left,\n          top: top,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (!this.temporalRect) return this;\n      Object.keys(this.temporalRect).forEach(function (key) {\n        var value = _this6.temporalRect[key];\n        _this6.el.style[key] = value - containmentRect[key] + 'px';\n      });\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_removeHandlers\",\n    value: function _removeHandlers() {\n      this.handlers.forEach(function (handle) {\n        return handle.destroy();\n      });\n      delete this.handlers;\n      return this;\n    }\n  }]);\n\n  return DDResizable;\n}(dd_base_impl_1.DDBaseImplement);\n\nexports.DDResizable = DDResizable;\n/** @internal */\n\nDDResizable._originStyleProp = ['width', 'height', 'position', 'left', 'top', 'opacity', 'zIndex'];\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-resizable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/dd-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/dd-utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDUtils = void 0;\n/**\r\n * dd-utils.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nvar DDUtils = /*#__PURE__*/function () {\n  function DDUtils() {\n    _classCallCheck(this, DDUtils);\n  }\n\n  _createClass(DDUtils, null, [{\n    key: \"clone\",\n    value: function clone(el) {\n      var node = el.cloneNode(true);\n      node.removeAttribute('id');\n      return node;\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(el, parent) {\n      var parentNode;\n\n      if (typeof parent === 'string') {\n        parentNode = document.querySelector(parent);\n      } else {\n        parentNode = parent;\n      }\n\n      if (parentNode) {\n        parentNode.appendChild(el);\n      }\n    }\n  }, {\n    key: \"setPositionRelative\",\n    value: function setPositionRelative(el) {\n      if (!/^(?:r|a|f)/.test(window.getComputedStyle(el).position)) {\n        el.style.position = \"relative\";\n      }\n    }\n  }, {\n    key: \"addElStyles\",\n    value: function addElStyles(el, styles) {\n      if (styles instanceof Object) {\n        var _loop = function _loop(s) {\n          if (styles.hasOwnProperty(s)) {\n            if (Array.isArray(styles[s])) {\n              // support fallback value\n              styles[s].forEach(function (val) {\n                el.style[s] = val;\n              });\n            } else {\n              el.style[s] = styles[s];\n            }\n          }\n        };\n\n        for (var s in styles) {\n          _loop(s);\n        }\n      }\n    }\n  }, {\n    key: \"initEvent\",\n    value: function initEvent(e, info) {\n      var evt = {\n        type: info.type\n      };\n      var obj = {\n        button: 0,\n        which: 0,\n        buttons: 1,\n        bubbles: true,\n        cancelable: true,\n        target: info.target ? info.target : e.target\n      }; // don't check for `instanceof DragEvent` as Safari use MouseEvent #1540\n\n      if (e.dataTransfer) {\n        evt['dataTransfer'] = e.dataTransfer; // workaround 'readonly' field.\n      }\n\n      ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].forEach(function (p) {\n        return evt[p] = e[p];\n      }); // keys\n\n      ['pageX', 'pageY', 'clientX', 'clientY', 'screenX', 'screenY'].forEach(function (p) {\n        return evt[p] = e[p];\n      }); // point info\n\n      return Object.assign(Object.assign({}, evt), obj);\n    }\n  }]);\n\n  return DDUtils;\n}();\n\nexports.DDUtils = DDUtils;\n\nDDUtils.isEventSupportPassiveOption = function () {\n  var supportsPassive = false;\n\n  var passiveTest = function passiveTest() {// do nothing\n  };\n\n  document.addEventListener('test', passiveTest, {\n    get passive() {\n      supportsPassive = true;\n      return true;\n    }\n\n  });\n  document.removeEventListener('test', passiveTest);\n  return supportsPassive;\n}();\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/dd-utils.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/h5/gridstack-dd-native.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridstack/dist/h5/gridstack-dd-native.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\r\n * gridstack-dd-native.ts 4.2.6\r\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\r\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) {\n    if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridStackDDNative = void 0;\n\nvar dd_manager_1 = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/h5/dd-manager.js\");\n\nvar dd_element_1 = __webpack_require__(/*! ./dd-element */ \"./node_modules/gridstack/dist/h5/dd-element.js\");\n\nvar gridstack_dd_1 = __webpack_require__(/*! ../gridstack-dd */ \"./node_modules/gridstack/dist/gridstack-dd.js\");\n\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/gridstack/dist/utils.js\"); // export our base class (what user should use) and all associated types\n\n\n__exportStar(__webpack_require__(/*! ../gridstack-dd */ \"./node_modules/gridstack/dist/gridstack-dd.js\"), exports);\n/**\r\n * HTML 5 Native DragDrop based drag'n'drop plugin.\r\n */\n\n\nvar GridStackDDNative = /*#__PURE__*/function (_gridstack_dd_1$GridS) {\n  _inherits(GridStackDDNative, _gridstack_dd_1$GridS);\n\n  var _super = _createSuper(GridStackDDNative);\n\n  function GridStackDDNative() {\n    _classCallCheck(this, GridStackDDNative);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridStackDDNative, [{\n    key: \"resizable\",\n    value: function resizable(el, opts, key, value) {\n      this._getDDElements(el).forEach(function (dEl) {\n        if (opts === 'disable' || opts === 'enable') {\n          dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()\n        } else if (opts === 'destroy') {\n          dEl.ddResizable && dEl.cleanResizable();\n        } else if (opts === 'option') {\n          dEl.setupResizable(_defineProperty({}, key, value));\n        } else {\n          var grid = dEl.el.gridstackNode.grid;\n          var handles = dEl.el.getAttribute('gs-resize-handles') ? dEl.el.getAttribute('gs-resize-handles') : grid.opts.resizable.handles;\n          dEl.setupResizable(Object.assign(Object.assign(Object.assign({}, grid.opts.resizable), {\n            handles: handles\n          }), {\n            start: opts.start,\n            stop: opts.stop,\n            resize: opts.resize\n          }));\n        }\n      });\n\n      return this;\n    }\n  }, {\n    key: \"draggable\",\n    value: function draggable(el, opts, key, value) {\n      this._getDDElements(el).forEach(function (dEl) {\n        if (opts === 'disable' || opts === 'enable') {\n          dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()\n        } else if (opts === 'destroy') {\n          dEl.ddDraggable && dEl.cleanDraggable();\n        } else if (opts === 'option') {\n          dEl.setupDraggable(_defineProperty({}, key, value));\n        } else {\n          var grid = dEl.el.gridstackNode.grid;\n          dEl.setupDraggable(Object.assign(Object.assign({}, grid.opts.draggable), {\n            containment: grid.opts._isNested && !grid.opts.dragOut ? grid.el.parentElement : grid.opts.draggable.containment || null,\n            start: opts.start,\n            stop: opts.stop,\n            drag: opts.drag\n          }));\n        }\n      });\n\n      return this;\n    }\n  }, {\n    key: \"dragIn\",\n    value: function dragIn(el, opts) {\n      this._getDDElements(el).forEach(function (dEl) {\n        return dEl.setupDraggable(opts);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"droppable\",\n    value: function droppable(el, opts, key, value) {\n      if (typeof opts.accept === 'function' && !opts._accept) {\n        opts._accept = opts.accept;\n\n        opts.accept = function (el) {\n          return opts._accept(el);\n        };\n      }\n\n      this._getDDElements(el).forEach(function (dEl) {\n        if (opts === 'disable' || opts === 'enable') {\n          dEl.ddDroppable && dEl.ddDroppable[opts]();\n        } else if (opts === 'destroy') {\n          if (dEl.ddDroppable) {\n            // error to call destroy if not there\n            dEl.cleanDroppable();\n          }\n        } else if (opts === 'option') {\n          dEl.setupDroppable(_defineProperty({}, key, value));\n        } else {\n          dEl.setupDroppable(opts);\n        }\n      });\n\n      return this;\n    }\n    /** true if element is droppable */\n\n  }, {\n    key: \"isDroppable\",\n    value: function isDroppable(el) {\n      return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);\n    }\n    /** true if element is draggable */\n\n  }, {\n    key: \"isDraggable\",\n    value: function isDraggable(el) {\n      return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);\n    }\n    /** true if element is draggable */\n\n  }, {\n    key: \"isResizable\",\n    value: function isResizable(el) {\n      return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);\n    }\n  }, {\n    key: \"on\",\n    value: function on(el, name, callback) {\n      this._getDDElements(el).forEach(function (dEl) {\n        return dEl.on(name, function (event) {\n          callback(event, dd_manager_1.DDManager.dragElement ? dd_manager_1.DDManager.dragElement.el : event.target, dd_manager_1.DDManager.dragElement ? dd_manager_1.DDManager.dragElement.helper : null);\n        });\n      });\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(el, name) {\n      this._getDDElements(el).forEach(function (dEl) {\n        return dEl.off(name);\n      });\n\n      return this;\n    }\n    /** @internal returns a list of DD elements, creating them on the fly by default */\n\n  }, {\n    key: \"_getDDElements\",\n    value: function _getDDElements(els) {\n      var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var hosts = utils_1.Utils.getElements(els);\n      if (!hosts.length) return [];\n      var list = hosts.map(function (e) {\n        return e.ddElement || (create ? dd_element_1.DDElement.init(e) : null);\n      });\n\n      if (!create) {\n        list.filter(function (d) {\n          return d;\n        });\n      } // remove nulls\n\n\n      return list;\n    }\n  }]);\n\n  return GridStackDDNative;\n}(gridstack_dd_1.GridStackDD);\n\nexports.GridStackDDNative = GridStackDDNative; // finally register ourself\n\ngridstack_dd_1.GridStackDD.registerPlugin(GridStackDDNative);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/gridstack/dist/h5/gridstack-dd-native.js?");

/***/ })

}]);