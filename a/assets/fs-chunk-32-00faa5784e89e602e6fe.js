(window["webpackJsonp_ember_auto_import_"] = window["webpackJsonp_ember_auto_import_"] || []).push([[32],{

/***/ "./node_modules/tributejs/dist/tribute.min.js":
/*!****************************************************!*\
  !*** ./node_modules/tributejs/dist/tribute.min.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  \"use strict\";\n\n  function e(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function t(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n    }\n  }\n\n  function n(e, n, i) {\n    return n && t(e.prototype, n), i && t(e, i), e;\n  }\n\n  function i(e, t) {\n    return function (e) {\n      if (Array.isArray(e)) return e;\n    }(e) || function (e, t) {\n      if (!(Symbol.iterator in Object(e) || \"[object Arguments]\" === Object.prototype.toString.call(e))) return;\n      var n = [],\n          i = !0,\n          r = !1,\n          o = void 0;\n\n      try {\n        for (var u, l = e[Symbol.iterator](); !(i = (u = l.next()).done) && (n.push(u.value), !t || n.length !== t); i = !0);\n      } catch (e) {\n        r = !0, o = e;\n      } finally {\n        try {\n          i || null == l.return || l.return();\n        } finally {\n          if (r) throw o;\n        }\n      }\n\n      return n;\n    }(e, t) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }();\n  }\n\n  if (Array.prototype.find || (Array.prototype.find = function (e) {\n    if (null === this) throw new TypeError(\"Array.prototype.find called on null or undefined\");\n    if (\"function\" != typeof e) throw new TypeError(\"predicate must be a function\");\n\n    for (var t, n = Object(this), i = n.length >>> 0, r = arguments[1], o = 0; o < i; o++) if (t = n[o], e.call(r, t, o, n)) return t;\n  }), window && \"function\" != typeof window.CustomEvent) {\n    var r = function (e, t) {\n      t = t || {\n        bubbles: !1,\n        cancelable: !1,\n        detail: void 0\n      };\n      var n = document.createEvent(\"CustomEvent\");\n      return n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), n;\n    };\n\n    void 0 !== window.Event && (r.prototype = window.Event.prototype), window.CustomEvent = r;\n  }\n\n  var o = function () {\n    function t(n) {\n      e(this, t), this.tribute = n, this.tribute.events = this;\n    }\n\n    return n(t, [{\n      key: \"bind\",\n      value: function (e) {\n        e.boundKeydown = this.keydown.bind(e, this), e.boundKeyup = this.keyup.bind(e, this), e.boundInput = this.input.bind(e, this), e.addEventListener(\"keydown\", e.boundKeydown, !1), e.addEventListener(\"keyup\", e.boundKeyup, !1), e.addEventListener(\"input\", e.boundInput, !1);\n      }\n    }, {\n      key: \"unbind\",\n      value: function (e) {\n        e.removeEventListener(\"keydown\", e.boundKeydown, !1), e.removeEventListener(\"keyup\", e.boundKeyup, !1), e.removeEventListener(\"input\", e.boundInput, !1), delete e.boundKeydown, delete e.boundKeyup, delete e.boundInput;\n      }\n    }, {\n      key: \"keydown\",\n      value: function (e, n) {\n        e.shouldDeactivate(n) && (e.tribute.isActive = !1, e.tribute.hideMenu());\n        var i = this;\n        e.commandEvent = !1, t.keys().forEach(function (t) {\n          t.key === n.keyCode && (e.commandEvent = !0, e.callbacks()[t.value.toLowerCase()](n, i));\n        });\n      }\n    }, {\n      key: \"input\",\n      value: function (e, t) {\n        e.inputEvent = !0, e.keyup.call(this, e, t);\n      }\n    }, {\n      key: \"click\",\n      value: function (e, t) {\n        var n = e.tribute;\n\n        if (n.menu && n.menu.contains(t.target)) {\n          var i = t.target;\n\n          for (t.preventDefault(), t.stopPropagation(); \"li\" !== i.nodeName.toLowerCase();) if (!(i = i.parentNode) || i === n.menu) throw new Error(\"cannot find the <li> container for the click\");\n\n          n.selectItemAtIndex(i.getAttribute(\"data-index\"), t), n.hideMenu();\n        } else n.current.element && !n.current.externalTrigger && (n.current.externalTrigger = !1, setTimeout(function () {\n          return n.hideMenu();\n        }));\n      }\n    }, {\n      key: \"keyup\",\n      value: function (e, t) {\n        if (e.inputEvent && (e.inputEvent = !1), e.updateSelection(this), 27 !== t.keyCode) {\n          if (!e.tribute.allowSpaces && e.tribute.hasTrailingSpace) return e.tribute.hasTrailingSpace = !1, e.commandEvent = !0, void e.callbacks().space(t, this);\n          if (!e.tribute.isActive) if (e.tribute.autocompleteMode) e.callbacks().triggerChar(t, this, \"\");else {\n            var n = e.getKeyCode(e, this, t);\n            if (isNaN(n) || !n) return;\n            var i = e.tribute.triggers().find(function (e) {\n              return e.charCodeAt(0) === n;\n            });\n            void 0 !== i && e.callbacks().triggerChar(t, this, i);\n          }\n          e.tribute.current.mentionText.length < e.tribute.current.collection.menuShowMinLength || ((e.tribute.current.trigger || e.tribute.autocompleteMode) && !1 === e.commandEvent || e.tribute.isActive && 8 === t.keyCode) && e.tribute.showMenuFor(this, !0);\n        }\n      }\n    }, {\n      key: \"shouldDeactivate\",\n      value: function (e) {\n        if (!this.tribute.isActive) return !1;\n\n        if (0 === this.tribute.current.mentionText.length) {\n          var n = !1;\n          return t.keys().forEach(function (t) {\n            e.keyCode === t.key && (n = !0);\n          }), !n;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"getKeyCode\",\n      value: function (e, t, n) {\n        var i = e.tribute,\n            r = i.range.getTriggerInfo(!1, i.hasTrailingSpace, !0, i.allowSpaces, i.autocompleteMode);\n        return !!r && r.mentionTriggerChar.charCodeAt(0);\n      }\n    }, {\n      key: \"updateSelection\",\n      value: function (e) {\n        this.tribute.current.element = e;\n        var t = this.tribute.range.getTriggerInfo(!1, this.tribute.hasTrailingSpace, !0, this.tribute.allowSpaces, this.tribute.autocompleteMode);\n        t && (this.tribute.current.selectedPath = t.mentionSelectedPath, this.tribute.current.mentionText = t.mentionText, this.tribute.current.selectedOffset = t.mentionSelectedOffset);\n      }\n    }, {\n      key: \"callbacks\",\n      value: function () {\n        var e = this;\n        return {\n          triggerChar: function (t, n, i) {\n            var r = e.tribute;\n            r.current.trigger = i;\n            var o = r.collection.find(function (e) {\n              return e.trigger === i;\n            });\n            r.current.collection = o, r.current.mentionText.length >= r.current.collection.menuShowMinLength && r.inputEvent && r.showMenuFor(n, !0);\n          },\n          enter: function (t, n) {\n            e.tribute.isActive && e.tribute.current.filteredItems && (t.preventDefault(), t.stopPropagation(), setTimeout(function () {\n              e.tribute.selectItemAtIndex(e.tribute.menuSelected, t), e.tribute.hideMenu();\n            }, 0));\n          },\n          escape: function (t, n) {\n            e.tribute.isActive && (t.preventDefault(), t.stopPropagation(), e.tribute.isActive = !1, e.tribute.hideMenu());\n          },\n          tab: function (t, n) {\n            e.callbacks().enter(t, n);\n          },\n          space: function (t, n) {\n            e.tribute.isActive && (e.tribute.spaceSelectsMatch ? e.callbacks().enter(t, n) : e.tribute.allowSpaces || (t.stopPropagation(), setTimeout(function () {\n              e.tribute.hideMenu(), e.tribute.isActive = !1;\n            }, 0)));\n          },\n          up: function (t, n) {\n            if (e.tribute.isActive && e.tribute.current.filteredItems) {\n              t.preventDefault(), t.stopPropagation();\n              var i = e.tribute.current.filteredItems.length,\n                  r = e.tribute.menuSelected;\n              i > r && r > 0 ? (e.tribute.menuSelected--, e.setActiveLi()) : 0 === r && (e.tribute.menuSelected = i - 1, e.setActiveLi(), e.tribute.menu.scrollTop = e.tribute.menu.scrollHeight);\n            }\n          },\n          down: function (t, n) {\n            if (e.tribute.isActive && e.tribute.current.filteredItems) {\n              t.preventDefault(), t.stopPropagation();\n              var i = e.tribute.current.filteredItems.length - 1,\n                  r = e.tribute.menuSelected;\n              i > r ? (e.tribute.menuSelected++, e.setActiveLi()) : i === r && (e.tribute.menuSelected = 0, e.setActiveLi(), e.tribute.menu.scrollTop = 0);\n            }\n          },\n          delete: function (t, n) {\n            e.tribute.isActive && e.tribute.current.mentionText.length < 1 ? e.tribute.hideMenu() : e.tribute.isActive && e.tribute.showMenuFor(n);\n          }\n        };\n      }\n    }, {\n      key: \"setActiveLi\",\n      value: function (e) {\n        var t = this.tribute.menu.querySelectorAll(\"li\"),\n            n = t.length >>> 0;\n        e && (this.tribute.menuSelected = parseInt(e));\n\n        for (var i = 0; i < n; i++) {\n          var r = t[i];\n\n          if (i === this.tribute.menuSelected) {\n            r.classList.add(this.tribute.current.collection.selectClass);\n            var o = r.getBoundingClientRect(),\n                u = this.tribute.menu.getBoundingClientRect();\n\n            if (o.bottom > u.bottom) {\n              var l = o.bottom - u.bottom;\n              this.tribute.menu.scrollTop += l;\n            } else if (o.top < u.top) {\n              var s = u.top - o.top;\n              this.tribute.menu.scrollTop -= s;\n            }\n          } else r.classList.remove(this.tribute.current.collection.selectClass);\n        }\n      }\n    }, {\n      key: \"getFullHeight\",\n      value: function (e, t) {\n        var n = e.getBoundingClientRect().height;\n\n        if (t) {\n          var i = e.currentStyle || window.getComputedStyle(e);\n          return n + parseFloat(i.marginTop) + parseFloat(i.marginBottom);\n        }\n\n        return n;\n      }\n    }], [{\n      key: \"keys\",\n      value: function () {\n        return [{\n          key: 9,\n          value: \"TAB\"\n        }, {\n          key: 8,\n          value: \"DELETE\"\n        }, {\n          key: 13,\n          value: \"ENTER\"\n        }, {\n          key: 27,\n          value: \"ESCAPE\"\n        }, {\n          key: 32,\n          value: \"SPACE\"\n        }, {\n          key: 38,\n          value: \"UP\"\n        }, {\n          key: 40,\n          value: \"DOWN\"\n        }];\n      }\n    }]), t;\n  }(),\n      u = function () {\n    function t(n) {\n      e(this, t), this.tribute = n, this.tribute.menuEvents = this, this.menu = this.tribute.menu;\n    }\n\n    return n(t, [{\n      key: \"bind\",\n      value: function (e) {\n        var t = this;\n        this.menuClickEvent = this.tribute.events.click.bind(null, this), this.menuContainerScrollEvent = this.debounce(function () {\n          t.tribute.isActive && t.tribute.showMenuFor(t.tribute.current.element, !1);\n        }, 300, !1), this.windowResizeEvent = this.debounce(function () {\n          t.tribute.isActive && t.tribute.range.positionMenuAtCaret(!0);\n        }, 300, !1), this.tribute.range.getDocument().addEventListener(\"MSPointerDown\", this.menuClickEvent, !1), this.tribute.range.getDocument().addEventListener(\"mousedown\", this.menuClickEvent, !1), window.addEventListener(\"resize\", this.windowResizeEvent), this.menuContainer ? this.menuContainer.addEventListener(\"scroll\", this.menuContainerScrollEvent, !1) : window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n      }\n    }, {\n      key: \"unbind\",\n      value: function (e) {\n        this.tribute.range.getDocument().removeEventListener(\"mousedown\", this.menuClickEvent, !1), this.tribute.range.getDocument().removeEventListener(\"MSPointerDown\", this.menuClickEvent, !1), window.removeEventListener(\"resize\", this.windowResizeEvent), this.menuContainer ? this.menuContainer.removeEventListener(\"scroll\", this.menuContainerScrollEvent, !1) : window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n      }\n    }, {\n      key: \"debounce\",\n      value: function (e, t, n) {\n        var i,\n            r = arguments,\n            o = this;\n        return function () {\n          var u = o,\n              l = r,\n              s = n && !i;\n          clearTimeout(i), i = setTimeout(function () {\n            i = null, n || e.apply(u, l);\n          }, t), s && e.apply(u, l);\n        };\n      }\n    }]), t;\n  }(),\n      l = function () {\n    function t(n) {\n      e(this, t), this.tribute = n, this.tribute.range = this;\n    }\n\n    return n(t, [{\n      key: \"getDocument\",\n      value: function () {\n        var e;\n        return this.tribute.current.collection && (e = this.tribute.current.collection.iframe), e ? e.contentWindow.document : document;\n      }\n    }, {\n      key: \"positionMenuAtCaret\",\n      value: function (e) {\n        var t,\n            n = this,\n            i = this.tribute.current,\n            r = this.getTriggerInfo(!1, this.tribute.hasTrailingSpace, !0, this.tribute.allowSpaces, this.tribute.autocompleteMode);\n\n        if (void 0 !== r) {\n          if (!this.tribute.positionMenu) return void (this.tribute.menu.style.cssText = \"display: block;\");\n          t = this.isContentEditable(i.element) ? this.getContentEditableCaretPosition(r.mentionPosition) : this.getTextAreaOrInputUnderlinePosition(this.tribute.current.element, r.mentionPosition), this.tribute.menu.style.cssText = \"top: \".concat(t.top, \"px;\\n                                     left: \").concat(t.left, \"px;\\n                                     right: \").concat(t.right, \"px;\\n                                     bottom: \").concat(t.bottom, \"px;\\n                                     position: absolute;\\n                                     display: block;\"), \"auto\" === t.left && (this.tribute.menu.style.left = \"auto\"), \"auto\" === t.top && (this.tribute.menu.style.top = \"auto\"), e && this.scrollIntoView(), window.setTimeout(function () {\n            var i = {\n              width: n.tribute.menu.offsetWidth,\n              height: n.tribute.menu.offsetHeight\n            },\n                r = n.isMenuOffScreen(t, i),\n                o = window.innerWidth > i.width && (r.left || r.right),\n                u = window.innerHeight > i.height && (r.top || r.bottom);\n            (o || u) && (n.tribute.menu.style.cssText = \"display: none\", n.positionMenuAtCaret(e));\n          }, 0);\n        } else this.tribute.menu.style.cssText = \"display: none\";\n      }\n    }, {\n      key: \"selectElement\",\n      value: function (e, t, n) {\n        var i,\n            r = e;\n        if (t) for (var o = 0; o < t.length; o++) {\n          if (void 0 === (r = r.childNodes[t[o]])) return;\n\n          for (; r.length < n;) n -= r.length, r = r.nextSibling;\n\n          0 !== r.childNodes.length || r.length || (r = r.previousSibling);\n        }\n        var u = this.getWindowSelection();\n        (i = this.getDocument().createRange()).setStart(r, n), i.setEnd(r, n), i.collapse(!0);\n\n        try {\n          u.removeAllRanges();\n        } catch (e) {}\n\n        u.addRange(i), e.focus();\n      }\n    }, {\n      key: \"replaceTriggerText\",\n      value: function (e, t, n, i, r) {\n        var o = this.getTriggerInfo(!0, n, t, this.tribute.allowSpaces, this.tribute.autocompleteMode);\n\n        if (void 0 !== o) {\n          var u = this.tribute.current,\n              l = new CustomEvent(\"tribute-replaced\", {\n            detail: {\n              item: r,\n              instance: u,\n              context: o,\n              event: i\n            }\n          });\n\n          if (this.isContentEditable(u.element)) {\n            e += \"string\" == typeof this.tribute.replaceTextSuffix ? this.tribute.replaceTextSuffix : \" \";\n            var s = o.mentionPosition + o.mentionText.length;\n            this.tribute.autocompleteMode || (s += o.mentionTriggerChar.length), this.pasteHtml(e, o.mentionPosition, s);\n          } else {\n            var a = this.tribute.current.element,\n                c = \"string\" == typeof this.tribute.replaceTextSuffix ? this.tribute.replaceTextSuffix : \" \";\n            e += c;\n            var h = o.mentionPosition,\n                d = o.mentionPosition + o.mentionText.length + c.length;\n            this.tribute.autocompleteMode || (d += o.mentionTriggerChar.length - 1), a.value = a.value.substring(0, h) + e + a.value.substring(d, a.value.length), a.selectionStart = h + e.length, a.selectionEnd = h + e.length;\n          }\n\n          u.element.dispatchEvent(new CustomEvent(\"input\", {\n            bubbles: !0\n          })), u.element.dispatchEvent(l);\n        }\n      }\n    }, {\n      key: \"pasteHtml\",\n      value: function (e, t, n) {\n        var i, r;\n        r = this.getWindowSelection(), (i = this.getDocument().createRange()).setStart(r.anchorNode, t), i.setEnd(r.anchorNode, n), i.deleteContents();\n        var o = this.getDocument().createElement(\"div\");\n        o.innerHTML = e;\n\n        for (var u, l, s = this.getDocument().createDocumentFragment(); u = o.firstChild;) l = s.appendChild(u);\n\n        i.insertNode(s), l && ((i = i.cloneRange()).setStartAfter(l), i.collapse(!0), r.removeAllRanges(), r.addRange(i));\n      }\n    }, {\n      key: \"getWindowSelection\",\n      value: function () {\n        return this.tribute.collection.iframe ? this.tribute.collection.iframe.contentWindow.getSelection() : window.getSelection();\n      }\n    }, {\n      key: \"getNodePositionInParent\",\n      value: function (e) {\n        if (null === e.parentNode) return 0;\n\n        for (var t = 0; t < e.parentNode.childNodes.length; t++) {\n          if (e.parentNode.childNodes[t] === e) return t;\n        }\n      }\n    }, {\n      key: \"getContentEditableSelectedPath\",\n      value: function (e) {\n        var t = this.getWindowSelection(),\n            n = t.anchorNode,\n            i = [];\n\n        if (null != n) {\n          for (var r, o = n.contentEditable; null !== n && \"true\" !== o;) r = this.getNodePositionInParent(n), i.push(r), null !== (n = n.parentNode) && (o = n.contentEditable);\n\n          return i.reverse(), {\n            selected: n,\n            path: i,\n            offset: t.getRangeAt(0).startOffset\n          };\n        }\n      }\n    }, {\n      key: \"getTextPrecedingCurrentSelection\",\n      value: function () {\n        var e = this.tribute.current,\n            t = \"\";\n\n        if (this.isContentEditable(e.element)) {\n          var n = this.getWindowSelection().anchorNode;\n\n          if (null != n) {\n            var i = n.textContent,\n                r = this.getWindowSelection().getRangeAt(0).startOffset;\n            i && r >= 0 && (t = i.substring(0, r));\n          }\n        } else {\n          var o = this.tribute.current.element;\n\n          if (o) {\n            var u = o.selectionStart;\n            o.value && u >= 0 && (t = o.value.substring(0, u));\n          }\n        }\n\n        return t;\n      }\n    }, {\n      key: \"getLastWordInText\",\n      value: function (e) {\n        var t = (e = e.replace(/\\u00A0/g, \" \")).split(/\\s+/);\n        return t[t.length - 1].trim();\n      }\n    }, {\n      key: \"getTriggerInfo\",\n      value: function (e, t, n, i, r) {\n        var o,\n            u,\n            l,\n            s = this,\n            a = this.tribute.current;\n\n        if (this.isContentEditable(a.element)) {\n          var c = this.getContentEditableSelectedPath(a);\n          c && (o = c.selected, u = c.path, l = c.offset);\n        } else o = this.tribute.current.element;\n\n        var h = this.getTextPrecedingCurrentSelection(),\n            d = this.getLastWordInText(h);\n        if (r) return {\n          mentionPosition: h.length - d.length,\n          mentionText: d,\n          mentionSelectedElement: o,\n          mentionSelectedPath: u,\n          mentionSelectedOffset: l\n        };\n\n        if (null != h) {\n          var f,\n              m = -1;\n\n          if (this.tribute.collection.forEach(function (e) {\n            var t = e.trigger,\n                i = e.requireLeadingSpace ? s.lastIndexWithLeadingSpace(h, t) : h.lastIndexOf(t);\n            i > m && (m = i, f = t, n = e.requireLeadingSpace);\n          }), m >= 0 && (0 === m || !n || /[\\xA0\\s]/g.test(h.substring(m - 1, m)))) {\n            var p = h.substring(m + f.length, h.length);\n            f = h.substring(m, m + f.length);\n            var v = p.substring(0, 1),\n                g = p.length > 0 && (\" \" === v || \" \" === v);\n            t && (p = p.trim());\n            var b = i ? /[^\\S ]/g : /[\\xA0\\s]/g;\n            if (this.tribute.hasTrailingSpace = b.test(p), !g && (e || !b.test(p))) return {\n              mentionPosition: m,\n              mentionText: p,\n              mentionSelectedElement: o,\n              mentionSelectedPath: u,\n              mentionSelectedOffset: l,\n              mentionTriggerChar: f\n            };\n          }\n        }\n      }\n    }, {\n      key: \"lastIndexWithLeadingSpace\",\n      value: function (e, t) {\n        for (var n = e.split(\"\").reverse().join(\"\"), i = -1, r = 0, o = e.length; r < o; r++) {\n          for (var u = r === e.length - 1, l = /\\s/.test(n[r + 1]), s = !0, a = t.length - 1; a >= 0; a--) if (t[a] !== n[r - a]) {\n            s = !1;\n            break;\n          }\n\n          if (s && (u || l)) {\n            i = e.length - 1 - r;\n            break;\n          }\n        }\n\n        return i;\n      }\n    }, {\n      key: \"isContentEditable\",\n      value: function (e) {\n        return \"INPUT\" !== e.nodeName && \"TEXTAREA\" !== e.nodeName;\n      }\n    }, {\n      key: \"isMenuOffScreen\",\n      value: function (e, t) {\n        var n = window.innerWidth,\n            i = window.innerHeight,\n            r = document.documentElement,\n            o = (window.pageXOffset || r.scrollLeft) - (r.clientLeft || 0),\n            u = (window.pageYOffset || r.scrollTop) - (r.clientTop || 0),\n            l = \"number\" == typeof e.top ? e.top : u + i - e.bottom - t.height,\n            s = \"number\" == typeof e.right ? e.right : e.left + t.width,\n            a = \"number\" == typeof e.bottom ? e.bottom : e.top + t.height,\n            c = \"number\" == typeof e.left ? e.left : o + n - e.right - t.width;\n        return {\n          top: l < Math.floor(u),\n          right: s > Math.ceil(o + n),\n          bottom: a > Math.ceil(u + i),\n          left: c < Math.floor(o)\n        };\n      }\n    }, {\n      key: \"getMenuDimensions\",\n      value: function () {\n        var e = {\n          width: null,\n          height: null\n        };\n        return this.tribute.menu.style.cssText = \"top: 0px;\\n                                 left: 0px;\\n                                 position: fixed;\\n                                 display: block;\\n                                 visibility; hidden;\", e.width = this.tribute.menu.offsetWidth, e.height = this.tribute.menu.offsetHeight, this.tribute.menu.style.cssText = \"display: none;\", e;\n      }\n    }, {\n      key: \"getTextAreaOrInputUnderlinePosition\",\n      value: function (e, t, n) {\n        var i = null !== window.mozInnerScreenX,\n            r = this.getDocument().createElement(\"div\");\n        r.id = \"input-textarea-caret-position-mirror-div\", this.getDocument().body.appendChild(r);\n        var o = r.style,\n            u = window.getComputedStyle ? getComputedStyle(e) : e.currentStyle;\n        o.whiteSpace = \"pre-wrap\", \"INPUT\" !== e.nodeName && (o.wordWrap = \"break-word\"), o.position = \"absolute\", o.visibility = \"hidden\", [\"direction\", \"boxSizing\", \"width\", \"height\", \"overflowX\", \"overflowY\", \"borderTopWidth\", \"borderRightWidth\", \"borderBottomWidth\", \"borderLeftWidth\", \"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\", \"fontStyle\", \"fontVariant\", \"fontWeight\", \"fontStretch\", \"fontSize\", \"fontSizeAdjust\", \"lineHeight\", \"fontFamily\", \"textAlign\", \"textTransform\", \"textIndent\", \"textDecoration\", \"letterSpacing\", \"wordSpacing\"].forEach(function (e) {\n          o[e] = u[e];\n        }), i ? (o.width = \"\".concat(parseInt(u.width) - 2, \"px\"), e.scrollHeight > parseInt(u.height) && (o.overflowY = \"scroll\")) : o.overflow = \"hidden\", r.textContent = e.value.substring(0, t), \"INPUT\" === e.nodeName && (r.textContent = r.textContent.replace(/\\s/g, \" \"));\n        var l = this.getDocument().createElement(\"span\");\n        l.textContent = e.value.substring(t) || \".\", r.appendChild(l);\n        var s = e.getBoundingClientRect(),\n            a = document.documentElement,\n            c = (window.pageXOffset || a.scrollLeft) - (a.clientLeft || 0),\n            h = (window.pageYOffset || a.scrollTop) - (a.clientTop || 0),\n            d = 0,\n            f = 0;\n        this.menuContainerIsBody && (d = s.top, f = s.left);\n        var m = {\n          top: d + h + l.offsetTop + parseInt(u.borderTopWidth) + parseInt(u.fontSize) - e.scrollTop,\n          left: f + c + l.offsetLeft + parseInt(u.borderLeftWidth)\n        },\n            p = window.innerWidth,\n            v = window.innerHeight,\n            g = this.getMenuDimensions(),\n            b = this.isMenuOffScreen(m, g);\n        b.right && (m.right = p - m.left, m.left = \"auto\");\n        var y = this.tribute.menuContainer ? this.tribute.menuContainer.offsetHeight : this.getDocument().body.offsetHeight;\n\n        if (b.bottom) {\n          var w = y - (v - (this.tribute.menuContainer ? this.tribute.menuContainer.getBoundingClientRect() : this.getDocument().body.getBoundingClientRect()).top);\n          m.bottom = w + (v - s.top - l.offsetTop), m.top = \"auto\";\n        }\n\n        return (b = this.isMenuOffScreen(m, g)).left && (m.left = p > g.width ? c + p - g.width : c, delete m.right), b.top && (m.top = v > g.height ? h + v - g.height : h, delete m.bottom), this.getDocument().body.removeChild(r), m;\n      }\n    }, {\n      key: \"getContentEditableCaretPosition\",\n      value: function (e) {\n        var t,\n            n = this.getWindowSelection();\n        (t = this.getDocument().createRange()).setStart(n.anchorNode, e), t.setEnd(n.anchorNode, e), t.collapse(!1);\n        var i = t.getBoundingClientRect(),\n            r = document.documentElement,\n            o = (window.pageXOffset || r.scrollLeft) - (r.clientLeft || 0),\n            u = (window.pageYOffset || r.scrollTop) - (r.clientTop || 0),\n            l = {\n          left: i.left + o,\n          top: i.top + i.height + u\n        },\n            s = window.innerWidth,\n            a = window.innerHeight,\n            c = this.getMenuDimensions(),\n            h = this.isMenuOffScreen(l, c);\n        h.right && (l.left = \"auto\", l.right = s - i.left - o);\n        var d = this.tribute.menuContainer ? this.tribute.menuContainer.offsetHeight : this.getDocument().body.offsetHeight;\n\n        if (h.bottom) {\n          var f = d - (a - (this.tribute.menuContainer ? this.tribute.menuContainer.getBoundingClientRect() : this.getDocument().body.getBoundingClientRect()).top);\n          l.top = \"auto\", l.bottom = f + (a - i.top);\n        }\n\n        return (h = this.isMenuOffScreen(l, c)).left && (l.left = s > c.width ? o + s - c.width : o, delete l.right), h.top && (l.top = a > c.height ? u + a - c.height : u, delete l.bottom), this.menuContainerIsBody || (l.left = l.left ? l.left - this.tribute.menuContainer.offsetLeft : l.left, l.top = l.top ? l.top - this.tribute.menuContainer.offsetTop : l.top), l;\n      }\n    }, {\n      key: \"scrollIntoView\",\n      value: function (e) {\n        var t,\n            n = this.menu;\n\n        if (void 0 !== n) {\n          for (; void 0 === t || 0 === t.height;) if (0 === (t = n.getBoundingClientRect()).height && (void 0 === (n = n.childNodes[0]) || !n.getBoundingClientRect)) return;\n\n          var i = t.top,\n              r = i + t.height;\n          if (i < 0) window.scrollTo(0, window.pageYOffset + t.top - 20);else if (r > window.innerHeight) {\n            var o = window.pageYOffset + t.top - 20;\n            o - window.pageYOffset > 100 && (o = window.pageYOffset + 100);\n            var u = window.pageYOffset - (window.innerHeight - r);\n            u > o && (u = o), window.scrollTo(0, u);\n          }\n        }\n      }\n    }, {\n      key: \"menuContainerIsBody\",\n      get: function () {\n        return this.tribute.menuContainer === document.body || !this.tribute.menuContainer;\n      }\n    }]), t;\n  }(),\n      s = function () {\n    function t(n) {\n      e(this, t), this.tribute = n, this.tribute.search = this;\n    }\n\n    return n(t, [{\n      key: \"simpleFilter\",\n      value: function (e, t) {\n        var n = this;\n        return t.filter(function (t) {\n          return n.test(e, t);\n        });\n      }\n    }, {\n      key: \"test\",\n      value: function (e, t) {\n        return null !== this.match(e, t);\n      }\n    }, {\n      key: \"match\",\n      value: function (e, t, n) {\n        n = n || {};\n        t.length;\n        var i = n.pre || \"\",\n            r = n.post || \"\",\n            o = n.caseSensitive && t || t.toLowerCase();\n        if (n.skip) return {\n          rendered: t,\n          score: 0\n        };\n        e = n.caseSensitive && e || e.toLowerCase();\n        var u = this.traverse(o, e, 0, 0, []);\n        return u ? {\n          rendered: this.render(t, u.cache, i, r),\n          score: u.score\n        } : null;\n      }\n    }, {\n      key: \"traverse\",\n      value: function (e, t, n, i, r) {\n        if (t.length === i) return {\n          score: this.calculateScore(r),\n          cache: r.slice()\n        };\n\n        if (!(e.length === n || t.length - i > e.length - n)) {\n          for (var o, u, l = t[i], s = e.indexOf(l, n); s > -1;) {\n            if (r.push(s), u = this.traverse(e, t, s + 1, i + 1, r), r.pop(), !u) return o;\n            (!o || o.score < u.score) && (o = u), s = e.indexOf(l, s + 1);\n          }\n\n          return o;\n        }\n      }\n    }, {\n      key: \"calculateScore\",\n      value: function (e) {\n        var t = 0,\n            n = 1;\n        return e.forEach(function (i, r) {\n          r > 0 && (e[r - 1] + 1 === i ? n += n + 1 : n = 1), t += n;\n        }), t;\n      }\n    }, {\n      key: \"render\",\n      value: function (e, t, n, i) {\n        var r = e.substring(0, t[0]);\n        return t.forEach(function (o, u) {\n          r += n + e[o] + i + e.substring(o + 1, t[u + 1] ? t[u + 1] : e.length);\n        }), r;\n      }\n    }, {\n      key: \"filter\",\n      value: function (e, t, n) {\n        var i = this;\n        return n = n || {}, t.reduce(function (t, r, o, u) {\n          var l = r;\n          n.extract && ((l = n.extract(r)) || (l = \"\"));\n          var s = i.match(e, l, n);\n          return null != s && (t[t.length] = {\n            string: s.rendered,\n            score: s.score,\n            index: o,\n            original: r\n          }), t;\n        }, []).sort(function (e, t) {\n          var n = t.score - e.score;\n          return n || e.index - t.index;\n        });\n      }\n    }]), t;\n  }();\n\n  return function () {\n    function t(n) {\n      var i,\n          r = this,\n          a = n.values,\n          c = void 0 === a ? null : a,\n          h = n.iframe,\n          d = void 0 === h ? null : h,\n          f = n.selectClass,\n          m = void 0 === f ? \"highlight\" : f,\n          p = n.containerClass,\n          v = void 0 === p ? \"tribute-container\" : p,\n          g = n.itemClass,\n          b = void 0 === g ? \"\" : g,\n          y = n.trigger,\n          w = void 0 === y ? \"@\" : y,\n          T = n.autocompleteMode,\n          C = void 0 !== T && T,\n          S = n.selectTemplate,\n          E = void 0 === S ? null : S,\n          k = n.menuItemTemplate,\n          x = void 0 === k ? null : k,\n          M = n.lookup,\n          A = void 0 === M ? \"key\" : M,\n          L = n.fillAttr,\n          I = void 0 === L ? \"value\" : L,\n          N = n.collection,\n          O = void 0 === N ? null : N,\n          D = n.menuContainer,\n          P = void 0 === D ? null : D,\n          R = n.noMatchTemplate,\n          W = void 0 === R ? null : R,\n          H = n.requireLeadingSpace,\n          B = void 0 === H || H,\n          F = n.allowSpaces,\n          _ = void 0 !== F && F,\n          j = n.replaceTextSuffix,\n          Y = void 0 === j ? null : j,\n          z = n.positionMenu,\n          K = void 0 === z || z,\n          q = n.spaceSelectsMatch,\n          U = void 0 !== q && q,\n          X = n.searchOpts,\n          Q = void 0 === X ? {} : X,\n          V = n.menuItemLimit,\n          G = void 0 === V ? null : V,\n          J = n.menuShowMinLength,\n          Z = void 0 === J ? 0 : J;\n\n      if (e(this, t), this.autocompleteMode = C, this.menuSelected = 0, this.current = {}, this.inputEvent = !1, this.isActive = !1, this.menuContainer = P, this.allowSpaces = _, this.replaceTextSuffix = Y, this.positionMenu = K, this.hasTrailingSpace = !1, this.spaceSelectsMatch = U, this.autocompleteMode && (w = \"\", _ = !1), c) this.collection = [{\n        trigger: w,\n        iframe: d,\n        selectClass: m,\n        containerClass: v,\n        itemClass: b,\n        selectTemplate: (E || t.defaultSelectTemplate).bind(this),\n        menuItemTemplate: (x || t.defaultMenuItemTemplate).bind(this),\n        noMatchTemplate: (i = W, \"string\" == typeof i ? \"\" === i.trim() ? null : i : \"function\" == typeof i ? i.bind(r) : W || function () {\n          return \"<li>No Match Found!</li>\";\n        }.bind(r)),\n        lookup: A,\n        fillAttr: I,\n        values: c,\n        requireLeadingSpace: B,\n        searchOpts: Q,\n        menuItemLimit: G,\n        menuShowMinLength: Z\n      }];else {\n        if (!O) throw new Error(\"[Tribute] No collection specified.\");\n        this.autocompleteMode && console.warn(\"Tribute in autocomplete mode does not work for collections\"), this.collection = O.map(function (e) {\n          return {\n            trigger: e.trigger || w,\n            iframe: e.iframe || d,\n            selectClass: e.selectClass || m,\n            containerClass: e.containerClass || v,\n            itemClass: e.itemClass || b,\n            selectTemplate: (e.selectTemplate || t.defaultSelectTemplate).bind(r),\n            menuItemTemplate: (e.menuItemTemplate || t.defaultMenuItemTemplate).bind(r),\n            noMatchTemplate: function (e) {\n              return \"string\" == typeof e ? \"\" === e.trim() ? null : e : \"function\" == typeof e ? e.bind(r) : W || function () {\n                return \"<li>No Match Found!</li>\";\n              }.bind(r);\n            }(W),\n            lookup: e.lookup || A,\n            fillAttr: e.fillAttr || I,\n            values: e.values,\n            requireLeadingSpace: e.requireLeadingSpace,\n            searchOpts: e.searchOpts || Q,\n            menuItemLimit: e.menuItemLimit || G,\n            menuShowMinLength: e.menuShowMinLength || Z\n          };\n        });\n      }\n      new l(this), new o(this), new u(this), new s(this);\n    }\n\n    return n(t, [{\n      key: \"triggers\",\n      value: function () {\n        return this.collection.map(function (e) {\n          return e.trigger;\n        });\n      }\n    }, {\n      key: \"attach\",\n      value: function (e) {\n        if (!e) throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n        if (\"undefined\" != typeof jQuery && e instanceof jQuery && (e = e.get()), e.constructor === NodeList || e.constructor === HTMLCollection || e.constructor === Array) for (var t = e.length, n = 0; n < t; ++n) this._attach(e[n]);else this._attach(e);\n      }\n    }, {\n      key: \"_attach\",\n      value: function (e) {\n        e.hasAttribute(\"data-tribute\") && console.warn(\"Tribute was already bound to \" + e.nodeName), this.ensureEditable(e), this.events.bind(e), e.setAttribute(\"data-tribute\", !0);\n      }\n    }, {\n      key: \"ensureEditable\",\n      value: function (e) {\n        if (-1 === t.inputTypes().indexOf(e.nodeName)) {\n          if (!e.contentEditable) throw new Error(\"[Tribute] Cannot bind to \" + e.nodeName);\n          e.contentEditable = !0;\n        }\n      }\n    }, {\n      key: \"createMenu\",\n      value: function (e) {\n        var t = this.range.getDocument().createElement(\"div\"),\n            n = this.range.getDocument().createElement(\"ul\");\n        return t.className = e, t.appendChild(n), this.menuContainer ? this.menuContainer.appendChild(t) : this.range.getDocument().body.appendChild(t);\n      }\n    }, {\n      key: \"showMenuFor\",\n      value: function (e, t) {\n        var n = this;\n\n        if (!this.isActive || this.current.element !== e || this.current.mentionText !== this.currentMentionTextSnapshot) {\n          this.currentMentionTextSnapshot = this.current.mentionText, this.menu || (this.menu = this.createMenu(this.current.collection.containerClass), e.tributeMenu = this.menu, this.menuEvents.bind(this.menu)), this.isActive = !0, this.menuSelected = 0, this.current.mentionText || (this.current.mentionText = \"\");\n\n          var r = function (e) {\n            if (n.isActive) {\n              var r = n.search.filter(n.current.mentionText, e, {\n                pre: n.current.collection.searchOpts.pre || \"<span>\",\n                post: n.current.collection.searchOpts.post || \"</span>\",\n                skip: n.current.collection.searchOpts.skip,\n                extract: function (e) {\n                  if (\"string\" == typeof n.current.collection.lookup) return e[n.current.collection.lookup];\n                  if (\"function\" == typeof n.current.collection.lookup) return n.current.collection.lookup(e, n.current.mentionText);\n                  throw new Error(\"Invalid lookup attribute, lookup must be string or function.\");\n                }\n              });\n              n.current.collection.menuItemLimit && (r = r.slice(0, n.current.collection.menuItemLimit)), n.current.filteredItems = r;\n              var o = n.menu.querySelector(\"ul\");\n\n              if (n.range.positionMenuAtCaret(t), !r.length) {\n                var u = new CustomEvent(\"tribute-no-match\", {\n                  detail: n.menu\n                });\n                return n.current.element.dispatchEvent(u), void (\"function\" == typeof n.current.collection.noMatchTemplate && !n.current.collection.noMatchTemplate() || !n.current.collection.noMatchTemplate ? n.hideMenu() : \"function\" == typeof n.current.collection.noMatchTemplate ? o.innerHTML = n.current.collection.noMatchTemplate() : o.innerHTML = n.current.collection.noMatchTemplate);\n              }\n\n              o.innerHTML = \"\";\n              var l = n.range.getDocument().createDocumentFragment();\n              r.forEach(function (e, t) {\n                var r = n.range.getDocument().createElement(\"li\");\n                r.setAttribute(\"data-index\", t), r.className = n.current.collection.itemClass, r.addEventListener(\"mousemove\", function (e) {\n                  var t = i(n._findLiTarget(e.target), 2),\n                      r = (t[0], t[1]);\n                  0 !== e.movementY && n.events.setActiveLi(r);\n                }), n.menuSelected === t && r.classList.add(n.current.collection.selectClass), r.innerHTML = n.current.collection.menuItemTemplate(e), l.appendChild(r);\n              }), o.appendChild(l);\n            }\n          };\n\n          \"function\" == typeof this.current.collection.values ? this.current.collection.values(this.current.mentionText, r) : r(this.current.collection.values);\n        }\n      }\n    }, {\n      key: \"_findLiTarget\",\n      value: function (e) {\n        if (!e) return [];\n        var t = e.getAttribute(\"data-index\");\n        return t ? [e, t] : this._findLiTarget(e.parentNode);\n      }\n    }, {\n      key: \"showMenuForCollection\",\n      value: function (e, t) {\n        e !== document.activeElement && this.placeCaretAtEnd(e), this.current.collection = this.collection[t || 0], this.current.externalTrigger = !0, this.current.element = e, e.isContentEditable ? this.insertTextAtCursor(this.current.collection.trigger) : this.insertAtCaret(e, this.current.collection.trigger), this.showMenuFor(e);\n      }\n    }, {\n      key: \"placeCaretAtEnd\",\n      value: function (e) {\n        if (e.focus(), void 0 !== window.getSelection && void 0 !== document.createRange) {\n          var t = document.createRange();\n          t.selectNodeContents(e), t.collapse(!1);\n          var n = window.getSelection();\n          n.removeAllRanges(), n.addRange(t);\n        } else if (void 0 !== document.body.createTextRange) {\n          var i = document.body.createTextRange();\n          i.moveToElementText(e), i.collapse(!1), i.select();\n        }\n      }\n    }, {\n      key: \"insertTextAtCursor\",\n      value: function (e) {\n        var t, n;\n        (n = (t = window.getSelection()).getRangeAt(0)).deleteContents();\n        var i = document.createTextNode(e);\n        n.insertNode(i), n.selectNodeContents(i), n.collapse(!1), t.removeAllRanges(), t.addRange(n);\n      }\n    }, {\n      key: \"insertAtCaret\",\n      value: function (e, t) {\n        var n = e.scrollTop,\n            i = e.selectionStart,\n            r = e.value.substring(0, i),\n            o = e.value.substring(e.selectionEnd, e.value.length);\n        e.value = r + t + o, i += t.length, e.selectionStart = i, e.selectionEnd = i, e.focus(), e.scrollTop = n;\n      }\n    }, {\n      key: \"hideMenu\",\n      value: function () {\n        this.menu && (this.menu.style.cssText = \"display: none;\", this.isActive = !1, this.menuSelected = 0, this.current = {});\n      }\n    }, {\n      key: \"selectItemAtIndex\",\n      value: function (e, t) {\n        if (\"number\" == typeof (e = parseInt(e)) && !isNaN(e)) {\n          var n = this.current.filteredItems[e],\n              i = this.current.collection.selectTemplate(n);\n          null !== i && this.replaceText(i, t, n);\n        }\n      }\n    }, {\n      key: \"replaceText\",\n      value: function (e, t, n) {\n        this.range.replaceTriggerText(e, !0, !0, t, n);\n      }\n    }, {\n      key: \"_append\",\n      value: function (e, t, n) {\n        if (\"function\" == typeof e.values) throw new Error(\"Unable to append to values, as it is a function.\");\n        e.values = n ? t : e.values.concat(t);\n      }\n    }, {\n      key: \"append\",\n      value: function (e, t, n) {\n        var i = parseInt(e);\n        if (\"number\" != typeof i) throw new Error(\"please provide an index for the collection to update.\");\n        var r = this.collection[i];\n\n        this._append(r, t, n);\n      }\n    }, {\n      key: \"appendCurrent\",\n      value: function (e, t) {\n        if (!this.isActive) throw new Error(\"No active state. Please use append instead and pass an index.\");\n\n        this._append(this.current.collection, e, t);\n      }\n    }, {\n      key: \"detach\",\n      value: function (e) {\n        if (!e) throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n        if (\"undefined\" != typeof jQuery && e instanceof jQuery && (e = e.get()), e.constructor === NodeList || e.constructor === HTMLCollection || e.constructor === Array) for (var t = e.length, n = 0; n < t; ++n) this._detach(e[n]);else this._detach(e);\n      }\n    }, {\n      key: \"_detach\",\n      value: function (e) {\n        var t = this;\n        this.events.unbind(e), e.tributeMenu && this.menuEvents.unbind(e.tributeMenu), setTimeout(function () {\n          e.removeAttribute(\"data-tribute\"), t.isActive = !1, e.tributeMenu && e.tributeMenu.remove();\n        });\n      }\n    }, {\n      key: \"isActive\",\n      get: function () {\n        return this._isActive;\n      },\n      set: function (e) {\n        if (this._isActive != e && (this._isActive = e, this.current.element)) {\n          var t = new CustomEvent(\"tribute-active-\".concat(e));\n          this.current.element.dispatchEvent(t);\n        }\n      }\n    }], [{\n      key: \"defaultSelectTemplate\",\n      value: function (e) {\n        return void 0 === e ? \"\".concat(this.current.collection.trigger).concat(this.current.mentionText) : this.range.isContentEditable(this.current.element) ? '<span class=\"tribute-mention\">' + (this.current.collection.trigger + e.original[this.current.collection.fillAttr]) + \"</span>\" : this.current.collection.trigger + e.original[this.current.collection.fillAttr];\n      }\n    }, {\n      key: \"defaultMenuItemTemplate\",\n      value: function (e) {\n        return e.string;\n      }\n    }, {\n      key: \"inputTypes\",\n      value: function () {\n        return [\"TEXTAREA\", \"INPUT\"];\n      }\n    }]), t;\n  }();\n});\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/tributejs/dist/tribute.min.js?");

/***/ })

}]);