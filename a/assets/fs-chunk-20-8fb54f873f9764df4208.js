(window["webpackJsonp_ember_auto_import_"] = window["webpackJsonp_ember_auto_import_"] || []).push([[20],{

/***/ "./node_modules/@fullcalendar/timegrid/main.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/main.js ***!
  \*****************************************************/
/*! exports provided: default, DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayTimeCols\", function() { return DayTimeCols; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayTimeColsSlicer\", function() { return DayTimeColsSlicer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DayTimeColsView\", function() { return DayTimeColsView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeCols\", function() { return TimeCols; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeColsSlatsCoords\", function() { return TimeColsSlatsCoords; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeColsView\", function() { return TimeColsView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildDayRanges\", function() { return buildDayRanges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildSlatMetas\", function() { return buildSlatMetas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildTimeColsModel\", function() { return buildTimeColsModel; });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.js\");\n/*!\nFullCalendar v6.0.0-beta.1\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/\n\n\nclass AllDaySplitter extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"Splitter\"] {\n  getKeyInfo() {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  }\n  getKeysForDateSpan(dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    }\n    return ['timed'];\n  }\n  getKeysForEventDef(eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    }\n    if (Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"hasBgRendering\"])(eventDef)) {\n      return ['timed', 'allDay'];\n    }\n    return ['allDay'];\n  }\n}\nconst DEFAULT_SLAT_LABEL_FORMAT = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createFormatter\"])({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\nfunction TimeColsAxisCell(props) {\n  let classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"ViewContextType\"].Consumer, null, context => {\n    if (!props.isLabeled) {\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n    let {\n      dateEnv,\n      options,\n      viewApi\n    } = context;\n    let labelFormat =\n    // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createFormatter\"])(options.slotLabelFormat[0]) : Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createFormatter\"])(options.slotLabelFormat);\n    let hookProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"RenderHook\"], {\n      hookProps: hookProps,\n      classNames: options.slotLabelClassNames,\n      content: options.slotLabelContent,\n      defaultContent: renderInnerContent,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, (rootElRef, customClassNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n      ref: rootElRef,\n      className: classNames.concat(customClassNames).join(' '),\n      \"data-time\": props.isoTimeStr\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n      ref: innerElRef\n    }, innerContent))));\n  });\n}\nfunction renderInnerContent(props) {\n  return props.text;\n}\nclass TimeBodyAxis extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  render() {\n    return this.props.slatMetas.map(slatMeta => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n      key: slatMeta.key\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColsAxisCell, Object.assign({}, slatMeta))));\n  }\n}\nconst DEFAULT_WEEK_NUM_FORMAT = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createFormatter\"])({\n  week: 'short'\n});\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nclass TimeColsView extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DateComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n    this.headerElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n    this.rootElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n    this.scrollerElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n    this.state = {\n      slatCoords: null\n    };\n    this.handleScrollTopRequest = scrollTop => {\n      let scrollerEl = this.scrollerElRef.current;\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    this.renderHeadAxis = (rowKey, frameHeight = '') => {\n      let {\n        options\n      } = this.context;\n      let {\n        dateProfile\n      } = this.props;\n      let range = dateProfile.renderRange;\n      let dayCnt = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"diffDays\"])(range.start, range.end);\n      let navLinkAttrs = dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)\n      ? Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"buildNavLinkAttrs\"])(this.context, range.start, 'week') : {};\n      if (options.weekNumbers && rowKey === 'day') {\n        return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"WeekNumberRoot\"], {\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, (rootElRef, classNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"th\", {\n          ref: rootElRef,\n          \"aria-hidden\": true,\n          className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n          className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n          style: {\n            height: frameHeight\n          }\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"a\", Object.assign({\n          ref: innerElRef,\n          className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n        }, navLinkAttrs), innerContent))));\n      }\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"th\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-axis\"\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n    this.renderTableRowAxis = rowHeight => {\n      let {\n        options,\n        viewApi\n      } = this.context;\n      let hookProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (\n        // TODO: make reusable hook. used in list view too\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"RenderHook\"], {\n          hookProps: hookProps,\n          classNames: options.allDayClassNames,\n          content: options.allDayContent,\n          defaultContent: renderAllDayInner,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, (rootElRef, classNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n          ref: rootElRef,\n          \"aria-hidden\": true,\n          className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n          className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),\n          style: {\n            height: rowHeight\n          }\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"span\", {\n          className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n          ref: innerElRef\n        }, innerContent))))\n      );\n    };\n    this.handleSlatCoords = slatCoords => {\n      this.setState({\n        slatCoords\n      });\n    };\n  }\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n  renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n    let {\n      context,\n      props\n    } = this;\n    let sections = [];\n    let stickyHeaderDates = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getStickyHeaderDates\"])(context.options);\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent:\n        // TODO: rename to cellContent so don't need to define <tr>?\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"ViewRoot\"], {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, (rootElRef, classNames) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: ['fc-timegrid'].concat(classNames).join(' '),\n      ref: rootElRef\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"SimpleScrollGrid\"], {\n      liquid: !props.isHeightAuto && !props.forPrint,\n      collapsibleWidth: props.forPrint,\n      cols: [{\n        width: 'shrink'\n      }],\n      sections: sections\n    })));\n  }\n  renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n    let {\n      context,\n      props\n    } = this;\n    let stickyHeaderDates = !props.forPrint && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getStickyHeaderDates\"])(context.options);\n    let stickyFooterScrollbar = !props.forPrint && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getStickyFooterScrollbar\"])(context.options);\n    let sections = [];\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: arg => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n            role: \"presentation\"\n          }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: contentArg => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n            role: \"presentation\"\n          }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent:\n        // TODO: rename to cellContent so don't need to define <tr>?\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n    let isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: arg =>\n        // TODO: make this now-indicator arrow more DRY with TimeColsContent\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n          className: \"fc-timegrid-axis-chunk\"\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"table\", {\n          \"aria-hidden\": true,\n          style: {\n            height: arg.expandRows ? arg.clientHeight : ''\n          }\n        }, arg.tableColGroupNode, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tbody\", null, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeBodyAxis, {\n          slatMetas: slatMetas\n        }))), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n          className: \"fc-timegrid-now-indicator-container\"\n        }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"NowTimer\"], {\n          unit: isNowIndicator ? 'minute' : 'day' /* hacky */\n        }, nowDate => {\n          let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n          if (typeof nowIndicatorTop === 'number') {\n            return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"NowIndicatorRoot\"], {\n              isAxis: true,\n              date: nowDate\n            }, (rootElRef, classNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n              ref: rootElRef,\n              className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n              style: {\n                top: nowIndicatorTop\n              }\n            }, innerContent));\n          }\n          return null;\n        })))\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"renderScrollShim\"]\n        }, {\n          key: 'cols',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"renderScrollShim\"]\n        }]\n      });\n    }\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"ViewRoot\"], {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, (rootElRef, classNames) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: ['fc-timegrid'].concat(classNames).join(' '),\n      ref: rootElRef\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(ScrollGrid, {\n      liquid: !props.isHeightAuto && !props.forPrint,\n      collapsibleWidth: false,\n      colGroups: [{\n        width: 'shrink',\n        cols: [{\n          width: 'shrink'\n        }]\n      }, {\n        cols: [{\n          span: colCnt,\n          minWidth: dayMinWidth\n        }]\n      }],\n      sections: sections\n    })));\n  }\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n  getAllDayMaxEventProps() {\n    let {\n      dayMaxEvents,\n      dayMaxEventRows\n    } = this.context.options;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n    return {\n      dayMaxEvents,\n      dayMaxEventRows\n    };\n  }\n}\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\nclass TimeColsSlatsCoords {\n  constructor(positions, dateProfile, slotDuration) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n  safeComputeTop(date) {\n    let {\n      dateProfile\n    } = this;\n    if (Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"rangeContainsMarker\"])(dateProfile.currentRange, date)) {\n      let startOfDayDate = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"startOfDay\"])(date);\n      let timeMs = date.valueOf() - startOfDayDate.valueOf();\n      if (timeMs >= Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"asRoughMs\"])(dateProfile.slotMinTime) && timeMs < Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"asRoughMs\"])(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop(Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createDuration\"])(timeMs));\n      }\n    }\n    return null;\n  }\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  computeDateTop(when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"startOfDay\"])(when);\n    }\n    return this.computeTimeTop(Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createDuration\"])(when.valueOf() - startOfDayDate.valueOf()));\n  }\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  computeTimeTop(duration) {\n    let {\n      positions,\n      dateProfile\n    } = this;\n    let len = positions.els.length;\n    // floating-point value of # of slots covered\n    let slatCoverage = (duration.milliseconds - Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"asRoughMs\"])(dateProfile.slotMinTime)) / Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"asRoughMs\"])(this.slotDuration);\n    let slatIndex;\n    let slatRemainder;\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage);\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1);\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  }\n}\nclass TimeColsSlatsBody extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      options\n    } = context;\n    let {\n      slatElRefs\n    } = props;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tbody\", null, props.slatMetas.map((slatMeta, i) => {\n      let hookProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      let classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColsAxisCell, Object.assign({}, slatMeta)), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"RenderHook\"], {\n        hookProps: hookProps,\n        classNames: options.slotLaneClassNames,\n        content: options.slotLaneContent,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, (rootElRef, customClassNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-time\": slatMeta.isoTimeStr\n      }, innerContent)));\n    }));\n  }\n}\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\nclass TimeColsSlats extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.rootElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n    this.slatElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"RefMap\"]();\n  }\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      ref: this.rootElRef,\n      className: \"fc-timegrid-slots\"\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  }\n  componentDidMount() {\n    this.updateSizing();\n  }\n  componentDidUpdate() {\n    this.updateSizing();\n  }\n  componentWillUnmount() {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  }\n  updateSizing() {\n    let {\n      context,\n      props\n    } = this;\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      let rootEl = this.rootElRef.current;\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"PositionCache\"](this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n      }\n    }\n  }\n}\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(slatMeta => elMap[slatMeta.key]);\n}\nfunction splitSegsByCol(segs, colCnt) {\n  let segsByCol = [];\n  let i;\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n  return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n  let byRow = [];\n  if (!ui) {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n    for (let seg of ui.segs) {\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n  return byRow;\n}\nclass TimeColMoreLink extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.rootElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n  }\n  render() {\n    let {\n      props\n    } = this;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"MoreLinkRoot\"], {\n      allDayDate: null,\n      moreCnt: props.hiddenSegs.length,\n      allSegs: props.hiddenSegs,\n      hiddenSegs: props.hiddenSegs,\n      alignmentElRef: this.rootElRef,\n      defaultContent: renderMoreLinkInner,\n      extraDateSpan: props.extraDateSpan,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props)\n    }, (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"a\", {\n      ref: el => {\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"setRef\"])(rootElRef, el);\n        Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"setRef\"])(this.rootElRef, el);\n      },\n      className: ['fc-timegrid-more-link'].concat(classNames).join(' '),\n      style: {\n        top: props.top,\n        bottom: props.bottom\n      },\n      onClick: handleClick,\n      title: title,\n      \"aria-expanded\": isExpanded,\n      \"aria-controls\": popoverId\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      ref: innerElRef,\n      className: \"fc-timegrid-more-link-inner fc-sticky\"\n    }, innerContent)));\n  }\n}\nfunction renderMoreLinkInner(props) {\n  return props.shortText;\n}\n\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n  let hierarchy = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"SegHierarchy\"]();\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n  let hiddenEntries = hierarchy.addSegs(segInputs);\n  let hiddenGroups = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"groupIntersectingEntries\"])(hiddenEntries);\n  let web = buildWeb(hierarchy);\n  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n  let segRects = webToRects(web);\n  return {\n    segRects,\n    hiddenGroups\n  };\n}\nfunction buildWeb(hierarchy) {\n  const {\n    entriesByLevel\n  } = hierarchy;\n  const buildNode = cacheable((level, lateral) => level + ':' + lateral, (level, lateral) => {\n    let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n    let nextLevelRes = buildNodes(siblingRange, buildNode);\n    let entry = entriesByLevel[level][lateral];\n    return [Object.assign(Object.assign({}, entry), {\n      nextLevelNodes: nextLevelRes[0]\n    }), entry.thickness + nextLevelRes[1] // the pressure builds\n    ];\n  });\n  return buildNodes(entriesByLevel.length ? {\n    level: 0,\n    lateralStart: 0,\n    lateralEnd: entriesByLevel[0].length\n  } : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n  if (!siblingRange) {\n    return [[], 0];\n  }\n  let {\n    level,\n    lateralStart,\n    lateralEnd\n  } = siblingRange;\n  let lateral = lateralStart;\n  let pairs = [];\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral));\n    lateral += 1;\n  }\n  pairs.sort(cmpDescPressures);\n  return [pairs.map(extractNode), pairs[0][1] // first item's pressure\n  ];\n}\nfunction cmpDescPressures(a, b) {\n  return b[1] - a[1];\n}\nfunction extractNode(a) {\n  return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n  let {\n    levelCoords,\n    entriesByLevel\n  } = hierarchy;\n  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n  let levelCnt = levelCoords.length;\n  let level = subjectLevel;\n  // skip past levels that are too high up\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n  for (; level < levelCnt; level += 1) {\n    let entries = entriesByLevel[level];\n    let entry;\n    let searchIndex = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"binarySearch\"])(entries, subjectEntry.span.start, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getEntrySpanEnd\"]);\n    let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n    let lateralEnd = lateralStart;\n    while (\n    // loop through entries that horizontally intersect\n    (entry = entries[lateralEnd]) &&\n    // but not past the whole seg list\n    entry.span.start < subjectEntry.span.end) {\n      lateralEnd += 1;\n    }\n    if (lateralStart < lateralEnd) {\n      return {\n        level,\n        lateralStart,\n        lateralEnd\n      };\n    }\n  }\n  return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n  const stretchNode = cacheable((node, startCoord, prevThickness) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"buildEntryKey\"])(node), (node, startCoord, prevThickness) => {\n    let {\n      nextLevelNodes,\n      thickness\n    } = node;\n    let allThickness = thickness + prevThickness;\n    let thicknessFraction = thickness / allThickness;\n    let endCoord;\n    let newChildren = [];\n    if (!nextLevelNodes.length) {\n      endCoord = totalThickness;\n    } else {\n      for (let childNode of nextLevelNodes) {\n        if (endCoord === undefined) {\n          let res = stretchNode(childNode, startCoord, allThickness);\n          endCoord = res[0];\n          newChildren.push(res[1]);\n        } else {\n          let res = stretchNode(childNode, endCoord, 0);\n          newChildren.push(res[1]);\n        }\n      }\n    }\n    let newThickness = (endCoord - startCoord) * thicknessFraction;\n    return [endCoord - newThickness, Object.assign(Object.assign({}, node), {\n      thickness: newThickness,\n      nextLevelNodes: newChildren\n    })];\n  });\n  return topLevelNodes.map(node => stretchNode(node, 0, 0)[1]);\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n  let rects = [];\n  const processNode = cacheable((node, levelCoord, stackDepth) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"buildEntryKey\"])(node), (node, levelCoord, stackDepth) => {\n    let rect = Object.assign(Object.assign({}, node), {\n      levelCoord,\n      stackDepth,\n      stackForward: 0\n    });\n    rects.push(rect);\n    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n  });\n  function processNodes(nodes, levelCoord, stackDepth) {\n    let stackForward = 0;\n    for (let node of nodes) {\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n    }\n    return stackForward;\n  }\n  processNodes(topLevelNodes, 0, 0);\n  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n  const cache = {};\n  return (...args) => {\n    let key = keyFunc(...args);\n    return key in cache ? cache[key] : cache[key] = workFunc(...args);\n  };\n}\nfunction computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {\n  let vcoords = [];\n  if (slatCoords) {\n    for (let i = 0; i < segs.length; i += 1) {\n      let seg = segs[i];\n      let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n      let spanEnd = Math.max(spanStart + (eventMinHeight || 0),\n      // :(\n      slatCoords.computeDateTop(seg.end, colDate));\n      vcoords.push({\n        start: Math.round(spanStart),\n        end: Math.round(spanEnd) //\n      });\n    }\n  }\n  return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords,\n// might not have for every seg\neventOrderStrict, eventMaxStack) {\n  let segInputs = [];\n  let dumbSegs = []; // segs without coords\n  for (let i = 0; i < segs.length; i += 1) {\n    let vcoords = segVCoords[i];\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords\n      });\n    } else {\n      dumbSegs.push(segs[i]);\n    }\n  }\n  let {\n    segRects,\n    hiddenGroups\n  } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n  let segPlacements = [];\n  for (let segRect of segRects) {\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect\n    });\n  }\n  for (let dumbSeg of dumbSegs) {\n    segPlacements.push({\n      seg: dumbSeg,\n      rect: null\n    });\n  }\n  return {\n    segPlacements,\n    hiddenGroups\n  };\n}\nconst DEFAULT_TIME_FORMAT = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createFormatter\"])({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\nclass TimeColEvent extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  render() {\n    let classNames = ['fc-timegrid-event', 'fc-v-event'];\n    if (this.props.isShort) {\n      classNames.push('fc-timegrid-event-short');\n    }\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"StandardEvent\"], Object.assign({}, this.props, {\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      extraClassNames: classNames\n    }));\n  }\n}\nclass TimeColMisc extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  render() {\n    let {\n      props\n    } = this;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DayCellContent\"], {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, (innerElRef, innerContent) => innerContent && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-col-misc\",\n      ref: innerElRef\n    }, innerContent));\n  }\n}\nclass TimeCol extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.sortEventSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"sortEventSegs\"]);\n  }\n  // TODO: memoize event-placement?\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let isSelectMirror = context.options.selectMirror;\n    let mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    let interactionAffectedInstances =\n    // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DayCellRoot\"], {\n      elRef: props.elRef,\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, (rootElRef, classNames, dataAttrs) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", Object.assign({\n      ref: rootElRef,\n      role: \"gridcell\",\n      className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')\n    }, dataAttrs, props.extraDataAttrs), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-col-bg\"\n    }, this.renderFillSegs(props.businessHourSegs, 'non-business'), this.renderFillSegs(props.bgEventSegs, 'bg-event'), this.renderFillSegs(props.dateSelectionSegs, 'highlight')), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-col-events\"\n    }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-col-events\"\n    }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, this.renderNowIndicator(props.nowIndicatorSegs)), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColMisc, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }))));\n  }\n  renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    let {\n      props\n    } = this;\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props);\n    }\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n  }\n  renderPositionedFgSegs(segs,\n  // if not mirror, needs to be sorted\n  segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    let {\n      eventMaxStack,\n      eventShortHeight,\n      eventOrderStrict,\n      eventMinHeight\n    } = this.context.options;\n    let {\n      date,\n      slatCoords,\n      eventSelection,\n      todayRange,\n      nowDate\n    } = this.props;\n    let isMirror = isDragging || isResizing || isDateSelecting;\n    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n    let {\n      segPlacements,\n      hiddenGroups\n    } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(segPlacement => {\n      let {\n        seg,\n        rect\n      } = segPlacement;\n      let instanceId = seg.eventRange.instance.instanceId;\n      let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n      let vStyle = computeSegVStyle(rect && rect.span);\n      let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : {\n        left: 0,\n        right: 0\n      };\n      let isInset = Boolean(rect) && rect.stackForward > 0;\n      let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n        className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: Object.assign(Object.assign({\n          visibility: isVisible ? '' : 'hidden'\n        }, vStyle), hStyle)\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColEvent, Object.assign({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === eventSelection,\n        isShort: isShort\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getSegMeta\"])(seg, todayRange, nowDate))));\n    }));\n  }\n  // will already have eventMinHeight applied because segInputs already had it\n  renderHiddenGroups(hiddenGroups, segs) {\n    let {\n      extraDateSpan,\n      dateProfile,\n      todayRange,\n      nowDate,\n      eventSelection,\n      eventDrag,\n      eventResize\n    } = this.props;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null, hiddenGroups.map(hiddenGroup => {\n      let positionCss = computeSegVStyle(hiddenGroup.span);\n      let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColMoreLink, {\n        key: Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"buildIsoString\"])(Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"computeEarliestSegStart\"])(hiddenSegs)),\n        hiddenSegs: hiddenSegs,\n        top: positionCss.top,\n        bottom: positionCss.bottom,\n        extraDateSpan: extraDateSpan,\n        dateProfile: dateProfile,\n        todayRange: todayRange,\n        nowDate: nowDate,\n        eventSelection: eventSelection,\n        eventDrag: eventDrag,\n        eventResize: eventResize\n      });\n    }));\n  }\n  renderFillSegs(segs, fillType) {\n    let {\n      props,\n      context\n    } = this;\n    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n    let children = segVCoords.map((vcoords, i) => {\n      let seg = segs[i];\n      return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n        key: Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"buildEventRangeKey\"])(seg.eventRange),\n        className: \"fc-timegrid-bg-harness\",\n        style: computeSegVStyle(vcoords)\n      }, fillType === 'bg-event' ? Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BgEvent\"], Object.assign({\n        seg: seg\n      }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getSegMeta\"])(seg, props.todayRange, props.nowDate))) : Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"renderFill\"])(fillType));\n    });\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null, children);\n  }\n  renderNowIndicator(segs) {\n    let {\n      slatCoords,\n      date\n    } = this.props;\n    if (!slatCoords) {\n      return null;\n    }\n    return segs.map((seg, i) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"NowIndicatorRoot\"], {\n      isAxis: false,\n      date: date,\n      // key doesn't matter. will only ever be one\n      key: i\n    }, (rootElRef, classNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      ref: rootElRef,\n      className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),\n      style: {\n        top: slatCoords.computeDateTop(seg.start, date)\n      }\n    }, innerContent)));\n  }\n  computeSegHStyle(segHCoords) {\n    let {\n      isRtl,\n      options\n    } = this.context;\n    let shouldOverlap = options.slotEventOverlap;\n    let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n    let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n    let left; // amount of space from left edge, a fraction of the total width\n    let right; // amount of space from right edge, a fraction of the total width\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n    }\n    if (isRtl) {\n      left = 1 - farCoord;\n      right = nearCoord;\n    } else {\n      left = nearCoord;\n      right = 1 - farCoord;\n    }\n    let props = {\n      zIndex: segHCoords.stackDepth + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n    return props;\n  }\n}\nfunction renderPlainFgSegs(sortedFgSegs, {\n  todayRange,\n  nowDate,\n  eventSelection,\n  eventDrag,\n  eventResize\n}) {\n  let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n  return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null, sortedFgSegs.map(seg => {\n    let instanceId = seg.eventRange.instance.instanceId;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      key: instanceId,\n      style: {\n        visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n      }\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColEvent, Object.assign({\n      seg: seg,\n      isDragging: false,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: instanceId === eventSelection,\n      isShort: false\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"getSegMeta\"])(seg, todayRange, nowDate))));\n  }));\n}\nfunction computeSegVStyle(segVCoords) {\n  if (!segVCoords) {\n    return {\n      top: '',\n      bottom: ''\n    };\n  }\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end\n  };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n  return segEntries.map(segEntry => allSegs[segEntry.index]);\n}\nclass TimeColsContent extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"BaseComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.splitFgEventSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitSegsByCol);\n    this.splitBgEventSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitSegsByCol);\n    this.splitBusinessHourSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitSegsByCol);\n    this.splitNowIndicatorSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitSegsByCol);\n    this.splitDateSelectionSegs = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitSegsByCol);\n    this.splitEventDrag = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitInteractionByCol);\n    this.splitEventResize = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(splitInteractionByCol);\n    this.rootElRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n    this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"RefMap\"]();\n  }\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n    let colCnt = props.cells.length;\n    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-cols\",\n      ref: this.rootElRef\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"table\", {\n      role: \"presentation\",\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tbody\", {\n      role: \"presentation\"\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"tr\", {\n      role: \"row\"\n    }, props.axis && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"td\", {\n      \"aria-hidden\": true,\n      className: \"fc-timegrid-col fc-timegrid-axis\"\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, typeof nowIndicatorTop === 'number' && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"NowIndicatorRoot\"], {\n      isAxis: true,\n      date: props.nowDate\n    }, (rootElRef, classNames, innerElRef, innerContent) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      ref: rootElRef,\n      className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n      style: {\n        top: nowIndicatorTop\n      }\n    }, innerContent))))), props.cells.map((cell, i) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeCol, {\n      key: cell.key,\n      elRef: this.cellElRefs.createRef(cell.key),\n      dateProfile: props.dateProfile,\n      date: cell.date,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange,\n      extraHookProps: cell.extraHookProps,\n      extraDataAttrs: cell.extraDataAttrs,\n      extraClassNames: cell.extraClassNames,\n      extraDateSpan: cell.extraDateSpan,\n      fgEventSegs: fgEventSegsByRow[i],\n      bgEventSegs: bgEventSegsByRow[i],\n      businessHourSegs: businessHourSegsByRow[i],\n      nowIndicatorSegs: nowIndicatorSegsByRow[i],\n      dateSelectionSegs: dateSelectionSegsByRow[i],\n      eventDrag: eventDragByRow[i],\n      eventResize: eventResizeByRow[i],\n      slatCoords: props.slatCoords,\n      eventSelection: props.eventSelection,\n      forPrint: props.forPrint\n    }))))));\n  }\n  componentDidMount() {\n    this.updateCoords();\n  }\n  componentDidUpdate() {\n    this.updateCoords();\n  }\n  updateCoords() {\n    let {\n      props\n    } = this;\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"PositionCache\"](this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true,\n      // horizontal\n      false));\n    }\n  }\n}\nfunction collectCellEls(elMap, cells) {\n  return cells.map(cell => elMap[cell.key]);\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\nclass TimeCols extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DateComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.processSlotOptions = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(processSlotOptions);\n    this.state = {\n      slatCoords: null\n    };\n    this.handleRootEl = el => {\n      if (el) {\n        this.context.registerInteractiveComponent(this, {\n          el,\n          isHitComboAllowed: this.props.isHitComboAllowed\n        });\n      } else {\n        this.context.unregisterInteractiveComponent(this);\n      }\n    };\n    this.handleScrollRequest = request => {\n      let {\n        onScrollTopRequest\n      } = this.props;\n      let {\n        slatCoords\n      } = this.state;\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          let top = slatCoords.computeTimeTop(request.time);\n          top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n          if (top) {\n            top += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n          onScrollTopRequest(top);\n        }\n        return true;\n      }\n      return false;\n    };\n    this.handleColCoords = colCoords => {\n      this.colCoords = colCoords;\n    };\n    this.handleSlatCoords = slatCoords => {\n      this.setState({\n        slatCoords\n      });\n      if (this.props.onSlatCoords) {\n        this.props.onSlatCoords(slatCoords);\n      }\n    };\n  }\n  render() {\n    let {\n      props,\n      state\n    } = this;\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"div\", {\n      className: \"fc-timegrid-body\",\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */,\n      onCoords: this.handleSlatCoords\n    }), Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  }\n  componentDidMount() {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  }\n  componentDidUpdate(prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  }\n  componentWillUnmount() {\n    this.scrollResponder.detach();\n  }\n  queryHit(positionLeft, positionTop) {\n    let {\n      dateEnv,\n      options\n    } = this.context;\n    let {\n      colCoords\n    } = this;\n    let {\n      dateProfile\n    } = this.props;\n    let {\n      slatCoords\n    } = this.state;\n    let {\n      snapDuration,\n      snapsPerSlot\n    } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n    let colIndex = colCoords.leftToIndex(positionLeft);\n    let slatIndex = slatCoords.positions.topToIndex(positionTop);\n    if (colIndex != null && slatIndex != null) {\n      let cell = this.props.cells[colIndex];\n      let slatTop = slatCoords.positions.tops[slatIndex];\n      let slatHeight = slatCoords.positions.getHeight(slatIndex);\n      let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n      let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      let dayDate = this.props.cells[colIndex].date;\n      let time = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"addDurations\"])(dateProfile.slotMinTime, Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"multiplyDuration\"])(snapDuration, snapIndex));\n      let start = dateEnv.add(dayDate, time);\n      let end = dateEnv.add(start, snapDuration);\n      return {\n        dateProfile,\n        dateSpan: Object.assign({\n          range: {\n            start,\n            end\n          },\n          allDay: false\n        }, cell.extraDateSpan),\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        },\n        layer: 0\n      };\n    }\n    return null;\n  }\n}\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  let snapDuration = snapDurationOverride || slotDuration;\n  let snapsPerSlot = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"wholeDivideDurations\"])(slotDuration, snapDuration);\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1;\n    // TODO: say warning?\n  }\n  return {\n    snapDuration,\n    snapsPerSlot\n  };\n}\nclass DayTimeColsSlicer extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"Slicer\"] {\n  sliceRange(range, dayRanges) {\n    let segs = [];\n    for (let col = 0; col < dayRanges.length; col += 1) {\n      let segRange = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"intersectRanges\"])(range, dayRanges[col]);\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col\n        });\n      }\n    }\n    return segs;\n  }\n}\nclass DayTimeCols extends _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DateComponent\"] {\n  constructor() {\n    super(...arguments);\n    this.buildDayRanges = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(buildDayRanges);\n    this.slicer = new DayTimeColsSlicer();\n    this.timeColsRef = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"])();\n  }\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      dateProfile,\n      dayTableModel\n    } = props;\n    let isNowIndicator = context.options.nowIndicator;\n    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"NowTimer\"], {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, (nowDate, todayRange) => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(TimeCols, Object.assign({\n      ref: this.timeColsRef\n    }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n      forPrint: props.forPrint,\n      axis: props.axis,\n      dateProfile: dateProfile,\n      slatMetas: props.slatMetas,\n      slotDuration: props.slotDuration,\n      cells: dayTableModel.cells[0],\n      tableColGroupNode: props.tableColGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      expandRows: props.expandRows,\n      nowDate: nowDate,\n      nowIndicatorSegs: isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges),\n      todayRange: todayRange,\n      onScrollTopRequest: props.onScrollTopRequest,\n      onSlatCoords: props.onSlatCoords\n    })));\n  }\n}\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  let ranges = [];\n  for (let date of dayTableModel.headerDates) {\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n  return ranges;\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  let dayStart = new Date(0);\n  let slatTime = slotMinTime;\n  let slatIterator = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createDuration\"])(0);\n  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  let metas = [];\n  while (Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"asRoughMs\"])(slatTime) < Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"asRoughMs\"])(slotMaxTime)) {\n    let date = dateEnv.add(dayStart, slatTime);\n    let isLabeled = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"wholeDivideDurations\"])(slatIterator, labelInterval) !== null;\n    metas.push({\n      date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"formatIsoTimeString\"])(date),\n      isLabeled\n    });\n    slatTime = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"addDurations\"])(slatTime, slotDuration);\n    slatIterator = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"addDurations\"])(slatIterator, slotDuration);\n  }\n  return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  let i;\n  let labelInterval;\n  let slotsPerLabel;\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createDuration\"])(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"wholeDivideDurations\"])(labelInterval, slotDuration);\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n  return slotDuration; // fall back\n}\nclass DayTimeColsView extends TimeColsView {\n  constructor() {\n    super(...arguments);\n    this.buildTimeColsModel = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(buildTimeColsModel);\n    this.buildSlatMetas = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"memoize\"])(buildSlatMetas);\n  }\n  render() {\n    let {\n      options,\n      dateEnv,\n      dateProfileGenerator\n    } = this.context;\n    let {\n      props\n    } = this;\n    let {\n      dateProfile\n    } = props;\n    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    let splitProps = this.allDaySplitter.splitProps(props);\n    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    let {\n      dayMinWidth\n    } = options;\n    let hasAttachedAxis = !dayMinWidth;\n    let hasDetachedAxis = dayMinWidth;\n    let headerContent = options.dayHeaders && Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DayHeader\"], {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n    let allDayContent = options.allDaySlot !== false && (contentArg => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__[\"DayTable\"], Object.assign({}, splitProps.allDay, {\n      dateProfile: dateProfile,\n      dayTableModel: dayTableModel,\n      nextDayThreshold: options.nextDayThreshold,\n      tableMinWidth: contentArg.tableMinWidth,\n      colGroupNode: contentArg.tableColGroupNode,\n      renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null,\n      showWeekNumbers: false,\n      expandRows: false,\n      headerAlignElRef: this.headerElRef,\n      clientWidth: contentArg.clientWidth,\n      clientHeight: contentArg.clientHeight,\n      forPrint: props.forPrint\n    }, this.getAllDayMaxEventProps())));\n    let timeGridContent = contentArg => Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(DayTimeCols, Object.assign({}, splitProps.timed, {\n      dayTableModel: dayTableModel,\n      dateProfile: dateProfile,\n      axis: hasAttachedAxis,\n      slotDuration: options.slotDuration,\n      slatMetas: slatMetas,\n      forPrint: props.forPrint,\n      tableColGroupNode: contentArg.tableColGroupNode,\n      tableMinWidth: contentArg.tableMinWidth,\n      clientWidth: contentArg.clientWidth,\n      clientHeight: contentArg.clientHeight,\n      onSlatCoords: this.handleSlatCoords,\n      expandRows: contentArg.expandRows,\n      onScrollTopRequest: this.handleScrollTopRequest\n    }));\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  }\n}\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  let daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DaySeriesModel\"](dateProfile.renderRange, dateProfileGenerator);\n  return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"DayTableModel\"](daySeries, false);\n}\nconst OPTION_REFINERS = {\n  allDaySlot: Boolean\n};\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\nvar css_248z = \"\\n/*\\nA VERTICAL event\\n*/\\n\\n.fc-v-event { /* allowed to be top-level */\\n  display: block;\\n  border: 1px solid #3788d8;\\n  border: 1px solid var(--fc-event-border-color, #3788d8);\\n  background-color: #3788d8;\\n  background-color: var(--fc-event-bg-color, #3788d8)\\n\\n}\\n\\n.fc-v-event .fc-event-main {\\n    color: #fff;\\n    color: var(--fc-event-text-color, #fff);\\n    height: 100%;\\n  }\\n\\n.fc-v-event .fc-event-main-frame {\\n    height: 100%;\\n    display: flex;\\n    flex-direction: column;\\n  }\\n\\n.fc-v-event .fc-event-time {\\n    flex-grow: 0;\\n    flex-shrink: 0;\\n    max-height: 100%;\\n    overflow: hidden;\\n  }\\n\\n.fc-v-event .fc-event-title-container { /* a container for the sticky cushion */\\n    flex-grow: 1;\\n    flex-shrink: 1;\\n    min-height: 0; /* important for allowing to shrink all the way */\\n  }\\n\\n.fc-v-event .fc-event-title { /* will have fc-sticky on it */\\n    top: 0;\\n    bottom: 0;\\n    max-height: 100%; /* clip overflow */\\n    overflow: hidden;\\n  }\\n\\n.fc-v-event:not(.fc-event-start) {\\n    border-top-width: 0;\\n    border-top-left-radius: 0;\\n    border-top-right-radius: 0;\\n  }\\n\\n.fc-v-event:not(.fc-event-end) {\\n    border-bottom-width: 0;\\n    border-bottom-left-radius: 0;\\n    border-bottom-right-radius: 0;\\n  }\\n\\n.fc-v-event.fc-event-selected:before {\\n    /* expand hit area */\\n    left: -10px;\\n    right: -10px;\\n  }\\n\\n.fc-v-event {\\n\\n  /* resizer (mouse AND touch) */\\n\\n}\\n\\n.fc-v-event .fc-event-resizer-start {\\n    cursor: n-resize;\\n  }\\n\\n.fc-v-event .fc-event-resizer-end {\\n    cursor: s-resize;\\n  }\\n\\n.fc-v-event {\\n\\n  /* resizer for MOUSE */\\n\\n}\\n\\n.fc-v-event:not(.fc-event-selected) .fc-event-resizer {\\n      height: 8px;\\n      height: var(--fc-event-resizer-thickness, 8px);\\n      left: 0;\\n      right: 0;\\n    }\\n\\n.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start {\\n      top: -4px;\\n      top: calc(var(--fc-event-resizer-thickness, 8px) / -2);\\n    }\\n\\n.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end {\\n      bottom: -4px;\\n      bottom: calc(var(--fc-event-resizer-thickness, 8px) / -2);\\n    }\\n\\n.fc-v-event {\\n\\n  /* resizer for TOUCH (when event is \\\"selected\\\") */\\n\\n}\\n\\n.fc-v-event.fc-event-selected .fc-event-resizer {\\n      left: 50%;\\n      margin-left: -4px;\\n      margin-left: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n    }\\n\\n.fc-v-event.fc-event-selected .fc-event-resizer-start {\\n      top: -4px;\\n      top: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n    }\\n\\n.fc-v-event.fc-event-selected .fc-event-resizer-end {\\n      bottom: -4px;\\n      bottom: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\\n    }\\n.fc .fc-timegrid .fc-daygrid-body { /* the all-day daygrid within the timegrid view */\\n    z-index: 2; /* put above the timegrid-body so that more-popover is above everything. TODO: better solution */\\n  }\\n.fc .fc-timegrid-divider {\\n    padding: 0 0 2px; /* browsers get confused when you set height. use padding instead */\\n  }\\n.fc .fc-timegrid-body {\\n    position: relative;\\n    z-index: 1; /* scope the z-indexes of slots and cols */\\n    min-height: 100%; /* fill height always, even when slat table doesn't grow */\\n  }\\n.fc .fc-timegrid-axis-chunk { /* for advanced ScrollGrid */\\n    position: relative /* offset parent for now-indicator-container */\\n\\n  }\\n.fc .fc-timegrid-axis-chunk > table {\\n      position: relative;\\n      z-index: 1; /* above the now-indicator-container */\\n    }\\n.fc .fc-timegrid-slots {\\n    position: relative;\\n    z-index: 1;\\n  }\\n.fc .fc-timegrid-slot { /* a <td> */\\n    height: 1.5em;\\n    border-bottom: 0 /* each cell owns its top border */\\n  }\\n.fc .fc-timegrid-slot:empty:before {\\n      content: '\\\\00a0'; /* make sure there's at least an empty space to create height for height syncing */\\n    }\\n.fc .fc-timegrid-slot-minor {\\n    border-top-style: dotted;\\n  }\\n.fc .fc-timegrid-slot-label-cushion {\\n    display: inline-block;\\n    white-space: nowrap;\\n  }\\n.fc .fc-timegrid-slot-label {\\n    vertical-align: middle; /* vertical align the slots */\\n  }\\n.fc {\\n\\n\\n  /* slots AND axis cells (top-left corner of view including the \\\"all-day\\\" text) */\\n\\n}\\n.fc .fc-timegrid-axis-cushion,\\n  .fc .fc-timegrid-slot-label-cushion {\\n    padding: 0 4px;\\n  }\\n.fc {\\n\\n\\n  /* axis cells (top-left corner of view including the \\\"all-day\\\" text) */\\n  /* vertical align is more complicated, uses flexbox */\\n\\n}\\n.fc .fc-timegrid-axis-frame-liquid {\\n    height: 100%; /* will need liquid-hack in FF */\\n  }\\n.fc .fc-timegrid-axis-frame {\\n    overflow: hidden;\\n    display: flex;\\n    align-items: center; /* vertical align */\\n    justify-content: flex-end; /* horizontal align. matches text-align below */\\n  }\\n.fc .fc-timegrid-axis-cushion {\\n    max-width: 60px; /* limits the width of the \\\"all-day\\\" text */\\n    flex-shrink: 0; /* allows text to expand how it normally would, regardless of constrained width */\\n  }\\n.fc-direction-ltr .fc-timegrid-slot-label-frame {\\n    text-align: right;\\n  }\\n.fc-direction-rtl .fc-timegrid-slot-label-frame {\\n    text-align: left;\\n  }\\n.fc-liquid-hack .fc-timegrid-axis-frame-liquid {\\n  height: auto;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  }\\n.fc .fc-timegrid-col.fc-day-today {\\n      background-color: rgba(255, 220, 40, 0.15);\\n      background-color: var(--fc-today-bg-color, rgba(255, 220, 40, 0.15));\\n    }\\n.fc .fc-timegrid-col-frame {\\n    min-height: 100%; /* liquid-hack is below */\\n    position: relative;\\n  }\\n.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame {\\n  height: auto;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n    }\\n.fc-media-screen .fc-timegrid-cols {\\n    position: absolute; /* no z-index. children will decide and go above slots */\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0\\n  }\\n.fc-media-screen .fc-timegrid-cols > table {\\n      height: 100%;\\n    }\\n.fc-media-screen .fc-timegrid-col-bg,\\n  .fc-media-screen .fc-timegrid-col-events,\\n  .fc-media-screen .fc-timegrid-now-indicator-container {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n  }\\n.fc {\\n\\n  /* bg */\\n\\n}\\n.fc .fc-timegrid-col-bg {\\n    z-index: 2; /* TODO: kill */\\n  }\\n.fc .fc-timegrid-col-bg .fc-non-business { z-index: 1 }\\n.fc .fc-timegrid-col-bg .fc-bg-event { z-index: 2 }\\n.fc .fc-timegrid-col-bg .fc-highlight { z-index: 3 }\\n.fc .fc-timegrid-bg-harness {\\n    position: absolute; /* top/bottom will be set by JS */\\n    left: 0;\\n    right: 0;\\n  }\\n.fc {\\n\\n  /* fg events */\\n  /* (the mirror segs are put into a separate container with same classname, */\\n  /* and they must be after the normal seg container to appear at a higher z-index) */\\n\\n}\\n.fc .fc-timegrid-col-events {\\n    z-index: 3;\\n    /* child event segs have z-indexes that are scoped within this div */\\n  }\\n.fc {\\n\\n  /* now indicator */\\n\\n}\\n.fc .fc-timegrid-now-indicator-container {\\n    bottom: 0;\\n    overflow: hidden; /* don't let overflow of lines/arrows cause unnecessary scrolling */\\n    /* z-index is set on the individual elements */\\n  }\\n.fc-direction-ltr .fc-timegrid-col-events {\\n    margin: 0 2.5% 0 2px;\\n  }\\n.fc-direction-rtl .fc-timegrid-col-events {\\n    margin: 0 2px 0 2.5%;\\n  }\\n.fc-timegrid-event-harness {\\n  position: absolute /* top/left/right/bottom will all be set by JS */\\n}\\n.fc-timegrid-event-harness > .fc-timegrid-event {\\n    position: absolute; /* absolute WITHIN the harness */\\n    top: 0; /* for when not yet positioned */\\n    bottom: 0; /* \\\" */\\n    left: 0;\\n    right: 0;\\n  }\\n.fc-timegrid-event-harness-inset .fc-timegrid-event,\\n.fc-timegrid-event.fc-event-mirror,\\n.fc-timegrid-more-link {\\n  box-shadow: 0px 0px 0px 1px #fff;\\n  box-shadow: 0px 0px 0px 1px var(--fc-page-bg-color, #fff);\\n}\\n.fc-timegrid-event,\\n.fc-timegrid-more-link { /* events need to be root */\\n  font-size: .85em;\\n  font-size: var(--fc-small-font-size, .85em);\\n  border-radius: 3px;\\n}\\n.fc-timegrid-event { /* events need to be root */\\n  margin-bottom: 1px /* give some space from bottom */\\n}\\n.fc-timegrid-event .fc-event-main {\\n    padding: 1px 1px 0;\\n  }\\n.fc-timegrid-event .fc-event-time {\\n    white-space: nowrap;\\n    font-size: .85em;\\n    font-size: var(--fc-small-font-size, .85em);\\n    margin-bottom: 1px;\\n  }\\n.fc-timegrid-event-short .fc-event-main-frame {\\n    flex-direction: row;\\n    overflow: hidden;\\n  }\\n.fc-timegrid-event-short .fc-event-time:after {\\n    content: '\\\\00a0-\\\\00a0'; /* dash surrounded by non-breaking spaces */\\n  }\\n.fc-timegrid-event-short .fc-event-title {\\n    font-size: .85em;\\n    font-size: var(--fc-small-font-size, .85em)\\n  }\\n.fc-timegrid-more-link { /* does NOT inherit from fc-timegrid-event */\\n  position: absolute;\\n  z-index: 9999; /* hack */\\n  color: inherit;\\n  color: var(--fc-more-link-text-color, inherit);\\n  background: #d0d0d0;\\n  background: var(--fc-more-link-bg-color, #d0d0d0);\\n  cursor: pointer;\\n  margin-bottom: 1px; /* match space below fc-timegrid-event */\\n}\\n.fc-timegrid-more-link-inner { /* has fc-sticky */\\n  padding: 3px 2px;\\n  top: 0;\\n}\\n.fc-direction-ltr .fc-timegrid-more-link {\\n    right: 0;\\n  }\\n.fc-direction-rtl .fc-timegrid-more-link {\\n    left: 0;\\n  }\\n.fc {\\n\\n  /* line */\\n\\n}\\n.fc .fc-timegrid-now-indicator-line {\\n    position: absolute;\\n    z-index: 4;\\n    left: 0;\\n    right: 0;\\n    border-style: solid;\\n    border-color: red;\\n    border-color: var(--fc-now-indicator-color, red);\\n    border-width: 1px 0 0;\\n  }\\n.fc {\\n\\n  /* arrow */\\n\\n}\\n.fc .fc-timegrid-now-indicator-arrow {\\n    position: absolute;\\n    z-index: 4;\\n    margin-top: -5px; /* vertically center on top coordinate */\\n    border-style: solid;\\n    border-color: red;\\n    border-color: var(--fc-now-indicator-color, red);\\n  }\\n.fc-direction-ltr .fc-timegrid-now-indicator-arrow {\\n    left: 0;\\n\\n    /* triangle pointing right. TODO: mixin */\\n    border-width: 5px 0 5px 6px;\\n    border-top-color: transparent;\\n    border-bottom-color: transparent;\\n  }\\n.fc-direction-rtl .fc-timegrid-now-indicator-arrow {\\n    right: 0;\\n\\n    /* triangle pointing left. TODO: mixin */\\n    border-width: 5px 6px 5px 0;\\n    border-top-color: transparent;\\n    border-bottom-color: transparent;\\n  }\\n\";\nstyleInject(css_248z);\nvar main = Object(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__[\"createPlugin\"])({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n    },\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@fullcalendar/timegrid/main.js?");

/***/ })

}]);